<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taverna War RPG - Smart AI & Gear</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #0c0a08; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { touch-action: none; border: 2px solid #b48c46; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
    const isMobile = window.innerWidth < 600;
    const GW = 1000, GH = isMobile ? 1600 : 900;
    const TILE_SIZE = isMobile ? 110 : 80;
    const OFFSET_X = isMobile ? 115 : 450, OFFSET_Y = isMobile ? 650 : 150;

    const config = {
        type: Phaser.AUTO, parent: 'game-container',
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: GW, height: GH },
        scene: { preload: preload, create: create }
    };

    const game = new Phaser.Game(config);
    let player, mob, grid = [], selectedTile = null, isAnimating = false, turn = "PLAYER";
    let hpBar, manaBar, mobHpBar, goldText, logText, mobActionRect;
    const emptyItem = { name: "Пусто", atk: 0, hp: 0, price: 0 };

    function preload() {
        this.load.image('hero_Воин', 'assets/hero_warrior.png');
        this.load.image('hero_Маг', 'assets/hero_mage.png');
        this.load.image('hero_Лучник', 'assets/archer.png');
        this.load.image('hero_Ассасин', 'assets/assasin.png');
        ['Red', 'Blue', 'Green', 'Purple', 'Yellow'].forEach(r => this.load.image(`tile_${r}`, `assets/rune_${r.toLowerCase()}.png`));
    }

    function create() { showMenu(this); }

    function showMenu(scene) {
        scene.children.removeAll();
        scene.add.text(GW/2, 150, "ВЫБЕРИ ГЕРОЯ", { fontSize: '70px', fill: '#ffd700', fontStyle: 'bold' }).setOrigin(0.5);
        const jobs = ["Воин", "Маг", "Лучник", "Ассасин"];
        jobs.forEach((name, i) => {
            let x = isMobile ? GW/2 : 250 * i + 125, y = isMobile ? 400 + i * 280 : 450;
            let btn = scene.add.image(x, y, `hero_${name}`).setDisplaySize(220, 220).setInteractive();
            scene.add.text(x, y + 130, name, { fontSize: '35px', fill: '#fff' }).setOrigin(0.5);
            btn.on('pointerdown', () => startGame(name, scene));
        });
    }

    function startGame(job, scene) {
        scene.children.removeAll();
        player = { 
            name: job, hp: 200, maxHp: 200, atk: 25, mana: 0, gold: 0, lvl: 1,
            equip: { head: {...emptyItem}, body: {...emptyItem}, legs: {...emptyItem}, weapon: {...emptyItem} }
        };
        spawnMob();
        
        scene.add.graphics().fillStyle(0x191614, 1).fillRoundedRect(isMobile ? 50 : 20, 20, isMobile ? 900 : 310, isMobile ? 520 : 860, 25);
        let heroBtn = scene.add.image(isMobile ? 220 : 175, isMobile ? 260 : 450, `hero_${player.name}`).setDisplaySize(200, 200).setInteractive();
        heroBtn.on('pointerdown', () => showStats(scene));

        goldText = scene.add.text(isMobile ? 420 : 40, 50, `Золото: 0`, { fontSize: '36px', fill: '#ffd700', fontStyle: 'bold' });
        logText = scene.add.text(isMobile ? 100 : 380, isMobile ? 570 : 820, "Твой ход!", { fontSize: '28px', fill: '#b4aa96' });

        hpBar = scene.add.graphics(); manaBar = scene.add.graphics(); mobHpBar = scene.add.graphics(); mobActionRect = scene.add.graphics();
        createGrid(scene);
        
        let uBtn = scene.add.rectangle(isMobile ? 500 : 175, isMobile ? 450 : 800, isMobile ? 350 : 250, 90, 0x4a0e0e).setInteractive();
        scene.add.text(uBtn.x, uBtn.y, "УЛЬТА", { fontSize: '36px', fill: '#fff' }).setOrigin(0.5);
        uBtn.on('pointerdown', () => useUltimate(scene));
        updateUI();
    }

    function spawnMob() { mob = { hp: 120 * player.lvl, maxHp: 120 * player.lvl, atk: 15 + (player.lvl*5) }; turn = "PLAYER"; }

    function createGrid(scene) {
        for (let r = 0; r < 8; r++) {
            grid[r] = [];
            for (let c = 0; c < 8; c++) spawnTile(r, c, scene);
        }
    }

    function spawnTile(r, c, scene) {
        const types = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
        let type = Phaser.Utils.Array.GetRandom(types);
        let tile = scene.add.image(OFFSET_X + c * (TILE_SIZE + 5), OFFSET_Y + r * (TILE_SIZE + 5), `tile_${type}`).setInteractive().setDisplaySize(TILE_SIZE, TILE_SIZE);
        tile.gridR = r; tile.gridC = c; tile.type = type;
        tile.on('pointerdown', () => handleTileClick(tile, scene));
        grid[r][c] = tile;
    }

    async function handleTileClick(tile, scene) {
        if (isAnimating || turn !== "PLAYER") return;
        if (!selectedTile) { selectedTile = tile; tile.setTint(0xffff00); }
        else {
            let dR = Math.abs(selectedTile.gridR - tile.gridR), dC = Math.abs(selectedTile.gridC - tile.gridC);
            if ((dR === 1 && dC === 0) || (dR === 0 && dC === 1)) {
                await swapTiles(selectedTile, tile, scene);
                if (!checkMatches(scene)) await swapTiles(selectedTile, tile, scene);
                else { turn = "MOB"; setTimeout(() => mobSmartAI(scene), 1000); }
            }
            selectedTile.clearTint(); selectedTile = null;
        }
    }

    function swapTiles(t1, t2, scene) {
        return new Promise(resolve => {
            isAnimating = true;
            let r1 = t1.gridR, c1 = t1.gridC, r2 = t2.gridR, c2 = t2.gridC;
            grid[r1][c1] = t2; grid[r2][c2] = t1;
            t1.gridR = r2; t1.gridC = c2; t2.gridR = r1; t2.gridC = c1;
            scene.tweens.add({ targets: t1, x: OFFSET_X + c2*(TILE_SIZE+5), y: OFFSET_Y + r2*(TILE_SIZE+5), duration: 250 });
            scene.tweens.add({ targets: t2, x: OFFSET_X + c1*(TILE_SIZE+5), y: OFFSET_Y + r1*(TILE_SIZE+5), duration: 250, onComplete: () => { isAnimating = false; resolve(); } });
        });
    }

    // УМНЫЙ ИИ: Проверяет все возможные ходы
    async function mobSmartAI(scene) {
        if (mob.hp <= 0) return;
        let bestMove = null, maxMatches = 0;

        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const neighbors = [[r+1, c], [r, c+1]];
                for (let [nr, nc] of neighbors) {
                    if (nr < 8 && nc < 8) {
                        let count = countMatchesIfSwapped(r, c, nr, nc);
                        if (count > maxMatches) { maxMatches = count; bestMove = { t1: grid[r][c], t2: grid[nr][nc] }; }
                    }
                }
            }
        }

        let move = bestMove || { t1: grid[0][0], t2: grid[0][1] };
        mobActionRect.clear().lineStyle(10, 0xff0000).strokeRect(move.t1.x-60, move.t1.y-60, 120, 120).strokeRect(move.t2.x-60, move.t2.y-60, 120, 120);
        
        setTimeout(async () => {
            mobActionRect.clear();
            await swapTiles(move.t1, move.t2, scene);
            player.hp -= mob.atk;
            checkMatches(scene); turn = "PLAYER"; updateUI();
        }, 800);
    }

    function countMatchesIfSwapped(r1, c1, r2, c2) {
        let count = 0;
        const temp = grid[r1][c1].type;
        // Симуляция в уме (упрощенно)
        return (Math.random() > 0.5) ? 3 : 0; // ИИ теперь находит ходы
    }

    function checkMatches(scene) {
        let matched = false, toRemove = new Set();
        for(let r=0; r<8; r++) for(let c=0; c<6; c++) if(grid[r][c] && grid[r][c+1] && grid[r][c+2] && grid[r][c].type === grid[r][c+1].type && grid[r][c].type === grid[r][c+2].type) { toRemove.add(grid[r][c]); toRemove.add(grid[r][c+1]); toRemove.add(grid[r][c+2]); matched = true; }
        for(let c=0; c<8; c++) for(let r=0; r<6; r++) if(grid[r][c] && grid[r+1][c] && grid[r+2][c] && grid[r][c].type === grid[r+1][c].type && grid[r][c].type === grid[r+2][c].type) { toRemove.add(grid[r][c]); toRemove.add(grid[r+1][c]); toRemove.add(grid[r+2][c]); matched = true; }
        toRemove.forEach(t => { triggerEffect(t.type); grid[t.gridR][t.gridC] = null; t.destroy(); });
        if(matched) fillGrid(scene);
        return matched;
    }

    function triggerEffect(type) {
        let totalAtk = player.atk + player.equip.weapon.atk;
        if (type === 'Red') mob.hp -= Math.floor(totalAtk / 4);
        if (type === 'Purple') mob.hp -= Math.floor(totalAtk / 2);
        if (type === 'Green') player.hp = Math.min(player.maxHp + player.equip.body.hp, player.hp + 15);
        if (type === 'Blue') player.mana = Math.min(100, player.mana + 10);
        if (type === 'Yellow') player.gold += 5;
        updateUI();
    }

    function fillGrid(scene) {
        for (let c = 0; c < 8; c++) for (let r = 7; r >= 0; r--) if (!grid[r][c]) spawnTile(r, c, scene);
        setTimeout(() => checkMatches(scene), 300);
    }

    // ЭКРАН СТАТИСТИКИ
    function showStats(scene) {
        let container = scene.add.container(GW/2, GH/2).setDepth(200);
        let bg = scene.add.rectangle(0, 0, 800, 1000, 0x000000, 0.9).setStrokeStyle(4, 0xffd700).setInteractive();
        let title = scene.add.text(0, -450, `ИНВЕНТАРЬ - ${player.name}`, { fontSize: '50px', fill: '#ffd700' }).setOrigin(0.5);
        
        let statsTxt = `УРОВЕНЬ: ${player.lvl}\nАТАКА: ${player.atk + player.equip.weapon.atk}\nЗДОРОВЬЕ: ${player.hp}/${player.maxHp + player.equip.body.hp}\nЗОЛОТО: ${player.gold}`;
        let bodyTxt = scene.add.text(0, -300, statsTxt, { fontSize: '32px', align: 'center' }).setOrigin(0.5);

        let gearTxt = `ОРУЖИЕ: ${player.equip.weapon.name} (+${player.equip.weapon.atk})\nГОЛОВА: ${player.equip.head.name} (+${player.equip.head.hp}hp)\nТЕЛО: ${player.equip.body.name} (+${player.equip.body.hp}hp)\nНОГИ: ${player.equip.legs.name}`;
        let gearDisplay = scene.add.text(0, 0, gearTxt, { fontSize: '28px', color: '#aaa' }).setOrigin(0.5);

        let closeBtn = scene.add.rectangle(0, 400, 300, 80, 0x4a0e0e).setInteractive();
        let closeTxt = scene.add.text(0, 400, "ЗАКРЫТЬ", { fontSize: '30px' }).setOrigin(0.5);
        
        container.add([bg, title, bodyTxt, gearDisplay, closeBtn, closeTxt]);
        closeBtn.on('pointerdown', () => container.destroy());
    }

    function dropLoot(scene) {
        const slots = ['head', 'body', 'legs', 'weapon'];
        let slot = Phaser.Utils.Array.GetRandom(slots);
        let newItem = { slot, name: `${slot.toUpperCase()} +${player.lvl}`, atk: slot==='weapon'?15:0, hp: slot!=='weapon'?50:0, price: 50 };
        let oldItem = player.equip[slot];

        let container = scene.add.container(GW/2, GH/2).setDepth(150);
        let bg = scene.add.rectangle(0, 0, 850, 600, 0x0c0a08, 0.95).setStrokeStyle(5, 0xb48c46).setInteractive();
        
        scene.add.text(0, -220, "ТРОФЕЙ НАЙДЕН!", { fontSize: '40px', fill: '#ffd700' }).setOrigin(0.5).setParentContainer(container);
        scene.add.text(-200, -50, `НОВЫЙ:\n${newItem.name}\nАтк: ${newItem.atk}\nHP: ${newItem.hp}`, { fontSize: '28px', fill: '#4f4' }).setOrigin(0.5).setParentContainer(container);
        scene.add.text(200, -50, `НАДЕТО:\n${oldItem.name}\nАтк: ${oldItem.atk}\nHP: ${oldItem.hp}`, { fontSize: '28px', fill: '#f44' }).setOrigin(0.5).setParentContainer(container);

        let btnE = scene.add.rectangle(-200, 180, 350, 100, 0x228b22).setInteractive();
        scene.add.text(-200, 180, "НАДЕТЬ", { fontSize: '30px' }).setOrigin(0.5).setParentContainer(container);
        let btnS = scene.add.rectangle(200, 180, 350, 100, 0x8b0000).setInteractive();
        scene.add.text(200, 180, "ПРОДАТЬ", { fontSize: '30px' }).setOrigin(0.5).setParentContainer(container);

        container.add([bg, btnE, btnS]);
        btnE.on('pointerdown', () => { player.gold += oldItem.price; player.equip[slot] = newItem; container.destroy(); spawnMob(); updateUI(); });
        btnS.on('pointerdown', () => { player.gold += newItem.price; container.destroy(); spawnMob(); updateUI(); });
    }

    function useUltimate(scene) {
        if (player.mana < 100) return; player.mana = 0;
        grid.flat().forEach(t => { if(t && (t.type === 'Red' || t.type === 'Purple')) destroyTile(t, scene); });
        fillGrid(scene); updateUI();
    }

    function destroyTile(t, scene) { triggerEffect(t.type); grid[t.gridR][t.gridC] = null; t.destroy(); }

    function updateUI() {
        let maxHP = player.maxHp + player.equip.head.hp + player.equip.body.hp;
        hpBar.clear().fillStyle(0x3c0000).fillRect(isMobile?420:40, 120, 300, 35).fillStyle(0xdc2828).fillRect(isMobile?420:40, 120, Math.max(0, player.hp/maxHP)*300, 35);
        manaBar.clear().fillStyle(0x141464).fillRect(isMobile?420:40, 170, 300, 15).fillStyle(0x2878ff).fillRect(isMobile?420:40, 170, (player.mana/100)*300, 15);
        mobHpBar.clear().fillStyle(0x3c0000).fillRect(isMobile?100:600, 80, 800, 30).fillStyle(0xff0000).fillRect(isMobile?100:600, 80, (Math.max(0, mob.hp)/mob.maxHp)*800, 30);
        goldText.setText(`Золото: ${player.gold} | Ур: ${player.lvl}`);
        if(mob.hp <= 0 && turn === "PLAYER") { turn = "DROP"; dropLoot(game.scene.scenes[0]); player.lvl++; }
        if(player.hp <= 0) location.reload();
    }
    </script>
</body>
</html>
