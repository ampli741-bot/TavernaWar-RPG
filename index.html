<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taverna War RPG - Stable PC Build</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { touch-action: none; border: 2px solid #333; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
    const isMobile = window.innerWidth < 600;
    const GW = 1000, GH = 900; // Фиксируем размер для ПК
    const TILE_SIZE = 80;
    const OFFSET_X = 450, OFFSET_Y = 150;

    const config = {
        type: Phaser.AUTO, parent: 'game-container',
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: GW, height: GH },
        scene: { preload: preload, create: create }
    };

    const game = new Phaser.Game(config);
    let player, mob, grid = [], selectedTile = null, isAnimating = false, turn = "PLAYER";
    let hpBar, manaBar, mobHpBar, goldText, logText, hpValTxt, manaValTxt, mobHpValTxt;
    const emptyItem = { name: "Ничего", atk: 0, hp: 0, price: 0 };

    function preload() {
        this.load.image('hero_Воин', 'assets/hero_warrior.png');
        this.load.image('hero_Маг', 'assets/hero_mage.png');
        this.load.image('hero_Лучник', 'assets/archer.png');
        this.load.image('hero_Ассасин', 'assets/assasin.png');
        this.load.image('mob_icon', 'assets/hero_warrior.png'); // Временная иконка для моба
        ['Red', 'Blue', 'Green', 'Purple', 'Yellow'].forEach(r => this.load.image(`tile_${r}`, `assets/rune_${r.toLowerCase()}.png`));
    }

    function create() { showMenu(this); }

    function showMenu(scene) {
        scene.children.removeAll();
        scene.add.text(GW/2, 150, "TAVERNA WAR", { fontSize: '80px', fill: '#ffd700', fontStyle: 'bold' }).setOrigin(0.5);
        const jobs = ["Воин", "Маг", "Лучник", "Ассасин"];
        jobs.forEach((name, i) => {
            let x = 250 * i + 125, y = 450;
            let btn = scene.add.image(x, y, `hero_${name}`).setDisplaySize(180, 180).setInteractive();
            scene.add.text(x, y + 120, name, { fontSize: '30px', fill: '#fff' }).setOrigin(0.5);
            btn.on('pointerdown', () => startGame(name, scene));
        });
    }

    function startGame(job, scene) {
        scene.children.removeAll();
        player = { 
            name: job, hp: 300, maxHp: 300, atk: 30, mana: 0, gold: 0, lvl: 1,
            equip: { head: {...emptyItem}, body: {...emptyItem}, legs: {...emptyItem}, weapon: {...emptyItem}, ring: {...emptyItem}, neck: {...emptyItem} }
        };
        spawnMob();
        
        // Панель игрока (Слева)
        scene.add.graphics().fillStyle(0x1a1a1a, 1).fillRoundedRect(20, 20, 310, 860, 20);
        let hBtn = scene.add.image(175, 250, `hero_${player.name}`).setDisplaySize(200, 200).setInteractive();
        hBtn.on('pointerdown', () => showStats(scene));

        // Полоски игрока
        hpBar = scene.add.graphics();
        manaBar = scene.add.graphics();
        hpValTxt = scene.add.text(175, 385, "", { fontSize: '22px', fill: '#fff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(100);
        manaValTxt = scene.add.text(175, 425, "", { fontSize: '18px', fill: '#fff' }).setOrigin(0.5).setDepth(100);

        // Панель моба (Справа сверху)
        scene.add.image(800, 250, 'mob_icon').setDisplaySize(150, 150).setAlpha(0.8);
        mobHpBar = scene.add.graphics();
        mobHpValTxt = scene.add.text(700, 102, "", { fontSize: '24px', fill: '#fff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(100);

        goldText = scene.add.text(40, 480, `ЗОЛОТО: 0`, { fontSize: '30px', fill: '#ffd700', fontStyle: 'bold' });
        logText = scene.add.text(GW/2, 850, "Твой ход!", { fontSize: '28px', fill: '#00ff00' }).setOrigin(0.5);

        createGrid(scene);
        updateUI();
    }

    function spawnMob() { 
        mob = { hp: 200 * player.lvl, maxHp: 200 * player.lvl, atk: 20 + (player.lvl * 5) }; 
        turn = "PLAYER"; 
    }

    function createGrid(scene) {
        for (let r = 0; r < 8; r++) { grid[r] = []; for (let c = 0; c < 8; c++) spawnTile(r, c, scene); }
    }

    function spawnTile(r, c, scene) {
        const types = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
        let type = types[Math.floor(Math.random()*types.length)];
        let tile = scene.add.image(OFFSET_X + c*(TILE_SIZE+5), OFFSET_Y + r*(TILE_SIZE+5), `tile_${type}`).setInteractive().setDisplaySize(TILE_SIZE, TILE_SIZE);
        tile.gridR = r; tile.gridC = c; tile.type = type;
        tile.on('pointerdown', () => handleTileClick(tile, scene));
        grid[r][c] = tile;
    }

    async function handleTileClick(tile, scene) {
        if (isAnimating || turn !== "PLAYER") return;
        if (!selectedTile) { selectedTile = tile; tile.setTint(0xffff00); }
        else {
            let dR = Math.abs(selectedTile.gridR - tile.gridR), dC = Math.abs(selectedTile.gridC - tile.gridC);
            if ((dR === 1 && dC === 0) || (dR === 0 && dC === 1)) {
                await swapTiles(selectedTile, tile, scene);
                if (!checkMatches(scene, "PLAYER")) await swapTiles(selectedTile, tile, scene);
                else { turn = "MOB"; setTimeout(() => mobTurn(scene), 600); }
            }
            selectedTile.clearTint(); selectedTile = null;
        }
    }

    function swapTiles(t1, t2, scene) {
        return new Promise(resolve => {
            isAnimating = true;
            let r1 = t1.gridR, c1 = t1.gridC, r2 = t2.gridR, c2 = t2.gridC;
            grid[r1][c1] = t2; grid[r2][c2] = t1;
            t1.gridR = r2; t1.gridC = c2; t2.gridR = r1; t2.gridC = c1;
            scene.tweens.add({ targets: t1, x: OFFSET_X + c2*(TILE_SIZE+5), y: OFFSET_Y + r2*(TILE_SIZE+5), duration: 200 });
            scene.tweens.add({ targets: t2, x: OFFSET_X + c1*(TILE_SIZE+5), y: OFFSET_Y + r1*(TILE_SIZE+5), duration: 200, onComplete: () => { isAnimating = false; resolve(); } });
        });
    }

    function mobTurn(scene) {
        if (mob.hp <= 0 || turn === "DROP") return;
        let moves = [];
        for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
            if (c < 7 && testMatch(r, c, r, c+1)) moves.push({t1: grid[r][c], t2: grid[r][c+1]});
            if (r < 7 && testMatch(r, c, r+1, c)) moves.push({t1: grid[r][c], t2: grid[r+1][c]});
        }
        if (moves.length > 0) {
            let move = moves[Math.floor(Math.random()*moves.length)];
            setTimeout(async () => {
                await swapTiles(move.t1, move.t2, scene);
                checkMatches(scene, "MOB");
                turn = "PLAYER"; updateUI();
            }, 500);
        } else { player.hp -= 15; turn = "PLAYER"; updateUI(); }
    }

    function testMatch(r1, c1, r2, c2) {
        let type1 = grid[r1][c1].type, type2 = grid[r2][c2].type;
        const check = (r, c, t) => {
            let h=1, v=1;
            for(let i=c-1; i>=0 && (r===r1 && i===c1?type2:r===r2 && i===c2?type1:grid[r][i].type)===t; i--) h++;
            for(let i=c+1; i<8 && (r===r1 && i===c1?type2:r===r2 && i===c2?type1:grid[r][i].type)===t; i++) h++;
            for(let i=r-1; i>=0 && (i===r1 && c===c1?type2:i===r2 && c===c2?type1:grid[i][c].type)===t; i--) v++;
            for(let i=r+1; i<8 && (i===r1 && c===c1?type2:i===r2 && c===c2?type1:grid[i][c].type)===t; i++) v++;
            return h>=3 || v>=3;
        };
        return check(r1, c1, type2) || check(r2, c2, type1);
    }

    function checkMatches(scene, owner) {
        let found = false, toRem = new Set();
        for(let r=0; r<8; r++) for(let c=0; c<6; c++) if(grid[r][c] && grid[r][c+1] && grid[r][c+2] && grid[r][c].type === grid[r][c+1].type && grid[r][c].type === grid[r][c+2].type) { toRem.add(grid[r][c]); toRem.add(grid[r][c+1]); toRem.add(grid[r][c+2]); found = true; }
        for(let c=0; c<8; c++) for(let r=0; r<6; r++) if(grid[r][c] && grid[r+1][c] && grid[r+2][c] && grid[r][c].type === grid[r+1][c].type && grid[r][c].type === grid[r+2][c].type) { toRem.add(grid[r][c]); toRem.add(grid[r+1][c]); toRem.add(grid[r+2][c]); found = true; }
        toRem.forEach(t => { effect(t.type, owner); grid[t.gridR][t.gridC] = null; t.destroy(); });
        if(found) fill(scene, owner);
        return found;
    }

    function effect(type, owner) {
        let maxP = player.maxHp + player.equip.head.hp + player.equip.body.hp + player.equip.legs.hp + player.equip.neck.hp;
        let atk = (owner === "PLAYER") ? (player.atk + player.equip.weapon.atk + player.equip.ring.atk) : mob.atk;
        if (type === 'Red') (owner === "PLAYER" ? mob : player).hp -= Math.floor(atk/3);
        if (type === 'Purple') (owner === "PLAYER" ? mob : player).hp -= Math.floor(atk/2);
        if (type === 'Green') (owner === "PLAYER" ? player : mob).hp = Math.min(owner==="PLAYER"?maxP:mob.maxHp, (owner==="PLAYER"?player.hp:mob.hp) + 25);
        if (type === 'Blue') (owner === "PLAYER" ? player : mob).mana = Math.min(100, (owner === "PLAYER" ? player.mana : 0) + 15);
        if (type === 'Yellow' && owner === "PLAYER") player.gold += 10;
        updateUI();
    }

    function fill(scene, owner) {
        for(let c=0; c<8; c++) for(let r=7; r>=0; r--) if(!grid[r][c]) spawnTile(r, c, scene);
        setTimeout(() => checkMatches(scene, owner), 300);
    }

    function showStats(scene) {
        let cont = scene.add.container(GW/2, GH/2).setDepth(500);
        let bg = scene.add.rectangle(0, 0, 700, 800, 0x000, 0.95).setStrokeStyle(4, 0xffd700).setInteractive();
        let txt = `--- ИНВЕНТАРЬ ---\n\nАТК: ${player.atk + player.equip.weapon.atk}\nЗОЛОТО: ${player.gold}\n\n`;
        const items = [player.equip.head, player.equip.body, player.equip.legs, player.equip.weapon, player.equip.ring, player.equip.neck];
        const names = ["Голова", "Тело", "Ноги", "Оружие", "Кольцо", "Амулет"];
        items.forEach((item, i) => { txt += `${names[i]}: ${item.name} (+${item.atk} ATK / +${item.hp} HP)\n`; });
        let info = scene.add.text(0, -50, txt, { fontSize: '24px', fill: '#fff', align: 'center' }).setOrigin(0.5);
        let btn = scene.add.rectangle(0, 350, 200, 60, 0x800).setInteractive();
        scene.add.text(0, 350, "ЗАКРЫТЬ", { fontSize: '28px' }).setOrigin(0.5);
        cont.add([bg, info, btn]);
        btn.on('pointerdown', () => cont.destroy());
    }

    function dropLoot(scene) {
        turn = "DROP";
        const slots = ['head', 'body', 'legs', 'weapon', 'ring', 'neck'];
        let slot = slots[Math.floor(Math.random()*slots.length)];
        let newItem = { slot, name: `${slot.toUpperCase()} +${player.lvl}`, atk: (slot==='weapon'||slot==='ring')?30+player.lvl*10:0, hp: (slot!=='weapon'&&slot!=='ring')?100+player.lvl*30:0, price: 50 };
        let oldItem = player.equip[slot];

        let cont = scene.add.container(GW/2, GH/2).setDepth(600);
        let bg = scene.add.rectangle(0, 0, 800, 600, 0x111, 0.98).setStrokeStyle(6, 0x0f0).setInteractive();
        scene.add.text(0, -230, "ПОБЕДА! НОВЫЙ ПРЕДМЕТ", { fontSize: '40px', fill: '#0f0' }).setOrigin(0.5);
        scene.add.text(-180, 0, `НОВЫЙ:\n${newItem.name}\nАТК: +${newItem.atk}\nHP: +${newItem.hp}`, { fontSize: '26px', fill: '#4f4' }).setOrigin(0.5);
        scene.add.text(180, 0, `НАДЕТО:\n${oldItem.name}\nАТК: +${oldItem.atk}\nHP: +${oldItem.hp}`, { fontSize: '26px', fill: '#f44' }).setOrigin(0.5);

        let bE = scene.add.rectangle(-180, 220, 250, 80, 0x282).setInteractive();
        scene.add.text(-180, 220, "НАДЕТЬ", { fontSize: '32px' }).setOrigin(0.5);
        let bS = scene.add.rectangle(180, 220, 250, 80, 0x822).setInteractive();
        scene.add.text(180, 220, "ПРОДАТЬ", { fontSize: '32px' }).setOrigin(0.5);

        cont.add([bg, bE, bS]);
        bE.on('pointerdown', () => { player.gold += oldItem.price; player.equip[slot] = newItem; cont.destroy(); player.lvl++; spawnMob(); updateUI(); });
        bS.on('pointerdown', () => { player.gold += newItem.price; cont.destroy(); player.lvl++; spawnMob(); updateUI(); });
    }

    function updateUI() {
        let maxP = player.maxHp + player.equip.head.hp + player.equip.body.hp + player.equip.legs.hp + player.equip.neck.hp;
        // Отрисовка полосок (ПК Координаты)
        hpBar.clear().fillStyle(0x300).fillRect(25, 370, 300, 35).fillStyle(0xd22).fillRect(25, 370, Math.min(1, player.hp/maxP)*300, 35);
        manaBar.clear().fillStyle(0x003).fillRect(25, 415, 300, 25).fillStyle(0x22f).fillRect(25, 415, (player.mana/100)*300, 25);
        mobHpBar.clear().fillStyle(0x300).fillRect(450, 80, 500, 45).fillStyle(0xf00).fillRect(450, 80, Math.max(0, mob.hp/mob.maxHp)*500, 45);
        
        hpValTxt.setText(`${Math.floor(player.hp)} / ${maxP}`);
        manaValTxt.setText(`${Math.floor(player.mana)}%`);
        mobHpValTxt.setText(`${Math.floor(Math.max(0, mob.hp))} / ${mob.maxHp}`);
        goldText.setText(`ЗОЛОТО: ${player.gold} | УР: ${player.lvl}`);

        if(mob.hp <= 0 && turn === "PLAYER") dropLoot(game.scene.scenes[0]);
        if(player.hp <= 0) location.reload();
    }
    </script>
</body>
</html>
