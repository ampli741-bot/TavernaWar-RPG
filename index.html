import React, { useState, useEffect, useCallback } from 'react';
import { 
  Flame, 
  Leaf, 
  Coins, 
  Skull, 
  Zap, 
  Heart, 
  RefreshCw, 
  Trophy,
  User,
  Shield,
  Sparkles,
  Sword
} from 'lucide-react';

// --- Константы скелета игры ---
const GRID_SIZE = 7;
const TILE_TYPES = [
  { id: 'fire', icon: Flame, color: '#ff4d00', shadow: '0 0 15px #ff4d00', label: 'Огонь', bg: 'rgba(255, 77, 0, 0.1)' },
  { id: 'leaf', icon: Leaf, color: '#32cd32', shadow: '0 0 15px #32cd32', label: 'Жизнь', bg: 'rgba(50, 205, 50, 0.1)' },
  { id: 'coin', icon: Coins, color: '#ffd700', shadow: '0 0 15px #ffd700', label: 'Золото', bg: 'rgba(255, 215, 0, 0.1)' },
  { id: 'dark', icon: Skull, color: '#9400d3', shadow: '0 0 15px #9400d3', label: 'Тьма', bg: 'rgba(148, 0, 211, 0.1)' },
  { id: 'mana', icon: Zap, color: '#00bfff', shadow: '0 0 15px #00bfff', label: 'Мана', bg: 'rgba(0, 191, 255, 0.1)' }
];

const App = () => {
  // --- Состояние (State) ---
  const [grid, setGrid] = useState([]);
  const [selectedTile, setSelectedTile] = useState(null);
  const [score, setScore] = useState(0);
  const [gold, setGold] = useState(0);
  const [mana, setMana] = useState(0);
  const [health, setHealth] = useState(100);
  const [isProcessing, setIsProcessing] = useState(false);
  const [matchingTiles, setMatchingTiles] = useState([]);

  // --- Логика инициализации ---
  const createGrid = useCallback(() => {
    const newGrid = [];
    for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
      newGrid.push({
        id: Math.random(),
        type: TILE_TYPES[Math.floor(Math.random() * TILE_TYPES.length)],
      });
    }
    setGrid(newGrid);
  }, []);

  useEffect(() => {
    createGrid();
  }, [createGrid]);

  // --- Базовая механика Match-3 ---
  const findMatches = (currentGrid) => {
    const matches = new Set();
    // Горизонтальный поиск
    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE - 2; c++) {
        const i = r * GRID_SIZE + c;
        if (currentGrid[i]?.type.id === currentGrid[i+1]?.type.id && 
            currentGrid[i]?.type.id === currentGrid[i+2]?.type.id) {
          [i, i+1, i+2].forEach(idx => matches.add(idx));
        }
      }
    }
    // Вертикальный поиск
    for (let c = 0; c < GRID_SIZE; c++) {
      for (let r = 0; r < GRID_SIZE - 2; r++) {
        const i = r * GRID_SIZE + c;
        const n1 = (r + 1) * GRID_SIZE + c;
        const n2 = (r + 2) * GRID_SIZE + c;
        if (currentGrid[i]?.type.id === currentGrid[n1]?.type.id && 
            currentGrid[i]?.type.id === currentGrid[n2]?.type.id) {
          [i, n1, n2].forEach(idx => matches.add(idx));
        }
      }
    }
    return Array.from(matches);
  };

  const handleMatches = async () => {
    let currentGrid = [...grid];
    let matches = findMatches(currentGrid);
    
    if (matches.length === 0) {
      setIsProcessing(false);
      return;
    }

    setMatchingTiles(matches);
    await new Promise(r => setTimeout(r, 400));

    // Начисление ресурсов (Механика скелета)
    matches.forEach(idx => {
      const type = currentGrid[idx].type.id;
      if (type === 'coin') setGold(g => g + 5);
      if (type === 'mana') setMana(m => Math.min(100, m + 2));
      if (type === 'leaf') setHealth(h => Math.min(100, h + 1));
    });
    setScore(s => s + (matches.length * 10));

    // Очистка и падение
    matches.forEach(idx => currentGrid[idx] = null);

    for (let c = 0; c < GRID_SIZE; c++) {
      let empty = GRID_SIZE - 1;
      for (let r = GRID_SIZE - 1; r >= 0; r--) {
        const i = r * GRID_SIZE + c;
        if (currentGrid[i] !== null) {
          const target = empty * GRID_SIZE + c;
          [currentGrid[target], currentGrid[i]] = [currentGrid[i], null];
          empty--;
        }
      }
      for (let r = empty; r >= 0; r--) {
        currentGrid[r * GRID_SIZE + c] = {
          id: Math.random(),
          type: TILE_TYPES[Math.floor(Math.random() * TILE_TYPES.length)]
        };
      }
    }

    setGrid(currentGrid);
    setMatchingTiles([]);
    setTimeout(() => handleMatches(), 300);
  };

  const handleTileClick = (index) => {
    if (isProcessing) return;
    if (selectedTile === null) {
      setSelectedTile(index);
    } else {
      const isAdj = Math.abs(Math.floor(selectedTile/GRID_SIZE) - Math.floor(index/GRID_SIZE)) + 
                    Math.abs((selectedTile%GRID_SIZE) - (index%GRID_SIZE)) === 1;
      if (isAdj) {
        const newGrid = [...grid];
        [newGrid[selectedTile], newGrid[index]] = [newGrid[index], newGrid[selectedTile]];
        if (findMatches(newGrid).length > 0) {
          setGrid(newGrid);
          setIsProcessing(true);
          handleMatches();
        }
      }
      setSelectedTile(null);
    }
  };

  return (
    <div className="min-h-screen bg-[#0f0e13] text-gray-100 p-4 font-sans flex flex-col items-center">
      {/* UI Панель: Ресурсы */}
      <div className="w-full max-w-md grid grid-cols-2 gap-4 mb-4">
        <div className="bg-[#1a1921] border border-gray-800 p-3 rounded-xl flex justify-between">
          <Trophy className="text-yellow-500 w-5 h-5" />
          <span className="font-mono font-bold">{score}</span>
        </div>
        <div className="bg-[#1a1921] border border-gray-800 p-3 rounded-xl flex justify-between">
          <Coins className="text-yellow-400 w-5 h-5" />
          <span className="font-mono font-bold">{gold}</span>
        </div>
      </div>

      {/* Прогресс-бары */}
      <div className="w-full max-w-md space-y-2 mb-6">
        <div className="h-2 bg-gray-900 rounded-full border border-gray-800">
          <div className="h-full bg-red-600 transition-all" style={{ width: `${health}%` }} />
        </div>
        <div className="h-2 bg-gray-900 rounded-full border border-gray-800">
          <div className="h-full bg-cyan-600 transition-all" style={{ width: `${mana}%` }} />
        </div>
      </div>

      {/* Сетка (Исправленная анимация без белых полей) */}
      <div className="relative bg-[#15141b] p-2 rounded-xl border-4 border-[#252331]">
        <div 
          className="grid gap-1"
          style={{ 
            gridTemplateColumns: `repeat(${GRID_SIZE}, minmax(0, 1fr))`,
            width: 'min(90vw, 380px)',
            height: 'min(90vw, 380px)'
          }}
        >
          {grid.map((tile, i) => {
            const isSel = selectedTile === i;
            const isMatch = matchingTiles.includes(i);
            const Icon = tile?.type.icon || Sparkles;

            return (
              <button
                key={tile?.id || i}
                onClick={() => handleTileClick(i)}
                disabled={isProcessing}
                className={`
                  relative aspect-square flex items-center justify-center rounded-md transition-all duration-200
                  ${isSel ? 'z-20 scale-105' : 'z-10'}
                  ${isMatch ? 'opacity-0 scale-50' : 'opacity-100'}
                `}
                style={{
                  background: tile?.type.bg || '#1a1921',
                  border: isSel ? `2px solid ${tile?.type.color}` : '1px solid rgba(255,255,255,0.05)',
                  boxShadow: isSel ? `0 0 15px ${tile?.type.color}` : 'none',
                  transformOrigin: 'center center' // Фикс наложения
                }}
              >
                <Icon 
                  style={{ color: tile?.type.color, filter: `drop-shadow(${tile?.type.shadow})` }} 
                  className={`w-3/5 h-3/5 transition-transform ${isSel ? 'scale-110' : ''}`}
                />
                
                {/* Метки ресурсов */}
                {tile?.type.id === 'mana' && <span className="absolute bottom-0.5 right-0.5 text-[7px] font-bold text-cyan-400">MP</span>}
                {tile?.type.id === 'leaf' && <span className="absolute bottom-0.5 right-0.5 text-[7px] font-bold text-green-400">HP</span>}
              </button>
            );
          })}
        </div>
      </div>

      {/* Футер скелета */}
      <div className="mt-auto w-full max-w-md p-4 bg-[#1a1921] rounded-t-3xl border-t border-gray-800 flex justify-between items-center">
        <div className="flex items-center gap-2">
          <div className="w-10 h-10 bg-indigo-900 rounded-full flex items-center justify-center">
            <User className="text-white w-6 h-6" />
          </div>
          <span className="text-xs font-bold uppercase tracking-widest">Герой</span>
        </div>
        <button onClick={createGrid} className="p-2 hover:bg-gray-800 rounded-lg">
          <RefreshCw className="w-5 h-5 text-gray-500" />
        </button>
      </div>
    </div>
  );
};

export default App;
