<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taverna War: Gothic Edition</title>
    <!-- Подключаем эпичный шрифт -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { 
            margin: 0; 
            /* Темный фон + картинка, если есть */
            background: #050505 url('assets/bg.jpg') no-repeat center center; 
            background-size: cover;
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; overflow: hidden; 
            touch-action: none; user-select: none; -webkit-user-select: none;
        }
        /* Тень для холста, чтобы выделить игру */
        canvas { box-shadow: 0 0 50px rgba(0,0,0,0.9); border: 1px solid #333; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
    const GW = 1200, GH = 900, TILE_S = 70;
    const GRID_SIZE = 8 * TILE_S;
    // Центрируем поле идеально
    const OFFSET_X = Math.floor((GW - GRID_SIZE) / 2);
    const OFFSET_Y = 175;

    // Стили шрифтов
    const FONT_MAIN = { fontFamily: 'Cinzel', fontSize: '20px', fill: '#e0c0a0', stroke: '#000', strokeThickness: 2 };
    const FONT_HEADER = { fontFamily: 'Cinzel', fontSize: '26px', fill: '#ffd700', stroke: '#000', strokeThickness: 4 };
    const FONT_DMG = { fontFamily: 'Cinzel', fontSize: '18px', stroke: '#000', strokeThickness: 3 };

    class MainScene extends Phaser.Scene {
        constructor() { super('MainScene'); }

        preload() {
            this.load.image('hero_Воин', 'assets/hero_warrior.png');
            this.load.image('hero_Маг', 'assets/hero_mage.png');
            this.load.image('hero_Лучник', 'assets/hero_archer.png');
            this.load.image('hero_Ассасин', 'assets/hero_assassin.png');
            ['Red', 'Blue', 'Green', 'Purple', 'Yellow'].forEach(c => 
                this.load.image(`tile_${c}`, `assets/rune_${c.toLowerCase()}.png`)
            );
        }

        create() { this.showMenu(); }

        // --- ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ ДЛЯ ГОТИЧЕСКИХ РАМОК ---
        drawGothicFrame(x, y, w, h) {
            let g = this.add.graphics().setDepth(0);
            // Фон панели (полупрозрачный черный)
            g.fillStyle(0x0a0502, 0.9);
            g.fillRect(x, y, w, h);
            // Золотая рамка
            g.lineStyle(4, 0x8a6f30, 1);
            g.strokeRect(x, y, w, h);
            // Внутренняя обводка
            g.lineStyle(2, 0x000000, 0.5);
            g.strokeRect(x+5, y+5, w-10, h-10);
            // "Болты" по углам
            g.fillStyle(0xffd700, 1);
            g.fillCircle(x, y, 6); g.fillCircle(x+w, y, 6);
            g.fillCircle(x, y+h, 6); g.fillCircle(x+w, y+h, 6);
            return g;
        }

        showMenu() {
            this.children.removeAll();
            this.add.text(GW/2, 100, "TAVERNA WAR", { fontFamily: 'Cinzel', fontSize: '60px', fill: '#ffd700', stroke: '#000', strokeThickness: 6 }).setOrigin(0.5);
            
            const heroes = [
                {n: "Воин", c: 0xff4400}, {n: "Маг", c: 0x0044ff}, {n: "Лучник", c: 0x00ff44}, {n: "Ассасин", c: 0x8800ff}
            ];
            
            heroes.forEach((h, i) => {
                let x = 250 * i + 225; // Распределяем по центру
                // Рамка карточки
                let card = this.add.rectangle(x, 450, 220, 400, 0x111111).setInteractive().setStrokeStyle(3, 0xb48c46);
                
                // Проверка картинки
                if(this.textures.exists(`hero_${h.n}`)) {
                    this.add.image(x, 400, `hero_${h.n}`).setDisplaySize(180, 180);
                } else {
                    this.add.rectangle(x, 400, 180, 180, h.c); // Заглушка цветом
                }

                this.add.text(x, 550, h.n, FONT_HEADER).setOrigin(0.5);
                card.on('pointerdown', () => this.startGame(h.n));
            });
        }

        startGame(job) {
            this.children.removeAll();
            const hps = { "Воин": 1400, "Маг": 720, "Лучник": 880, "Ассасин": 800 };
            this.player = {
                job, maxHp: hps[job], hp: hps[job], arm: 0, mana: 0, gold: 0, level: 1, baseAtk: 25,
                equip: { head: {n:"Шлем", arm:2}, body: {n:"Броня", arm:5}, legs: {n:"Сапоги", arm:2}, weapon: {n:"Меч", atk:12}, ring: {n:"Кольцо", atk:2}, neck: {n:"Амулет", atk:0} }
            };
            this.spawnMob();
            
            // Защитный слой для кликов
            this.add.rectangle(GW/2, GH/2, GW, GH, 0x000000, 0.001).setInteractive().setDepth(-10);

            this.createUI(); 
            this.initGrid();
            this.updateUI();
            
            // Фикс "пролистывания" - отключаем дефолтные действия
            this.input.setTopOnly(true);
        }

        spawnMob() {
            let lvl = this.player.level;
            this.mob = { name: "Монстр Ур." + lvl, maxHp: 100 + (lvl*60), hp: 100 + (lvl*60), atk: 15 + (lvl*10), mana: 0 };
            this.turn = "PLAYER";
            this.lootActive = false;
        }

        // ==========================================
        // [БЛОК UI: ГОТИЧЕСКИЙ СТИЛЬ]
        // ==========================================
        createUI() {
            // Левая рамка
            this.drawGothicFrame(20, 20, 310, 860);
            // Правая рамка
            this.drawGothicFrame(GW - 330, 20, 310, 860);

            // Игрок
            this.add.image(175, 120, `hero_${this.player.job}`).setDisplaySize(140, 140).setDepth(2);
            // Золотая рамка портрета
            this.add.graphics().lineStyle(3, 0xffd700).strokeRect(105, 50, 140, 140).setDepth(3);

            this.hpText = this.add.text(40, 210, "", FONT_MAIN).setDepth(2);
            this.hpBar = this.add.graphics().setDepth(2);
            this.armBar = this.add.graphics().setDepth(3); // Броня поверх ХП
            this.manaText = this.add.text(40, 280, "", { ...FONT_MAIN, fill: '#8888ff' }).setDepth(2);
            this.manaBar = this.add.graphics().setDepth(2);
            this.goldText = this.add.text(40, 335, "", { ...FONT_HEADER, fontSize: '22px' }).setDepth(2);
            
            // Кнопка Ульты
            this.ultBtn = this.add.rectangle(175, 410, 260, 50, 0x330033).setInteractive().setStrokeStyle(2, 0xaa00aa).setDepth(2);
            this.add.text(175, 410, "СУПЕРУДАР", FONT_HEADER).setOrigin(0.5).setDepth(2);
            this.ultBtn.on('pointerdown', (p, x, y, e) => { e.stopPropagation(); this.useUlt(); });
            
            this.add.text(175, 470, "ИНВЕНТАРЬ", { fontFamily: 'Cinzel', fontSize: '18px', fill: '#888' }).setOrigin(0.5).setDepth(2);
            
            // Тексты инвентаря
            this.equipTexts = {};
            ['head', 'body', 'legs', 'weapon', 'ring', 'neck'].forEach((s, i) => {
                this.equipTexts[s] = this.add.text(40, 500 + (i * 30), "", { fontFamily: 'Cinzel', fontSize: '15px', fill: '#aaa' }).setDepth(2);
            });

            // Моб
            this.mobIcon = this.add.image(GW - 175, 120, `hero_${this.player.job}`).setDisplaySize(140, 140).setTint(0x555555).setDepth(2);
            this.add.graphics().lineStyle(3, 0xff0000).strokeRect(GW - 245, 50, 140, 140).setDepth(3);
            
            this.mobHpText = this.add.text(GW - 175, 230, "", { ...FONT_HEADER, fill: '#ff4444' }).setOrigin(0.5).setDepth(2);
            this.mobHpBar = this.add.graphics().setDepth(2);
            this.mobManaBar = this.add.graphics().setDepth(2); // Мана моба
            
            // Лог боя
            this.logTexts = [];
            this.add.text(GW/2, 770, "ЖУРНАЛ БОЯ", { fontFamily: 'Cinzel', fontSize: '16px', fill: '#666' }).setOrigin(0.5);
            for (let i = 0; i < 5; i++) {
                this.logTexts.push(this.add.text(GW/2, 800 + (i * 20), "", { fontFamily: 'Arial', fontSize: '14px', fill: '#fff' }).setOrigin(0.5).setDepth(2));
            }
        }

        updateUI() {
            if (!this.player || !this.mob) return;
            let maxA = Object.values(this.player.equip).reduce((a, b) => a + (b.arm || 0), 0);
            
            this.hpText.setText(`HP: ${Math.floor(this.player.hp)} / ${this.player.maxHp}\nARM: ${this.player.arm}`);
            this.manaText.setText(`MANA: ${this.player.mana}%`);
            this.goldText.setText(`GOLD: ${this.player.gold}`);
            
            // Полоска ХП (темно-красный фон, ярко-красное заполнение)
            this.hpBar.clear().fillStyle(0x330000).fillRect(40, 250, 270, 16).fillStyle(0xaa0000).fillRect(40, 250, (Math.max(0, this.player.hp)/this.player.maxHp)*270, 16);
            
            // Полоска Брони (синяя, поверх ХП, тонкая)
            this.armBar.clear();
            if(maxA > 0) this.armBar.fillStyle(0x00aaff).fillRect(40, 250, (this.player.arm/maxA)*270, 4);

            this.manaBar.clear().fillStyle(0x000033).fillRect(40, 305, 270, 12).fillStyle(0x4444ff).fillRect(40, 305, (this.player.mana/100)*270, 12);
            
            for(let k in this.player.equip) {
                let item = this.player.equip[k];
                // Красим текст в зависимости от грейда (если бы он был)
                this.equipTexts[k].setText(`${item.n}: +${item.atk || 0} ATK / +${item.arm || 0} DEF`);
            }
            
            // Моб
            this.mobHpText.setText(`${this.mob.name}\nHP: ${Math.floor(this.mob.hp)}`);
            this.mobHpBar.clear().fillStyle(0x330000).fillRect(GW - 310, 280, 270, 16).fillStyle(0xaa0000).fillRect(GW - 310, 280, (Math.max(0, this.mob.hp)/this.mob.maxHp)*270, 16);
            // Мана моба (желтая)
            this.mobManaBar.clear().fillStyle(0x333300).fillRect(GW - 310, 305, 270, 8).fillStyle(0xffff00).fillRect(GW - 310, 305, (this.mob.mana/100)*270, 8);
            
            if(this.mob.hp <= 0 && !this.lootActive) this.showLootWindow(this.generateLoot()); 
            if(this.player.hp <= 0) location.reload();
        }

        // --- ЛОГИКА ИГРЫ (СКЕЛЕТ СОХРАНЕН) ---
        initGrid() {
            this.grid = []; this.isAnimating = false;
            // Подложка под сетку
            this.add.rectangle(GW/2, 450, GRID_SIZE+20, GRID_SIZE+20, 0x000000, 0.5).setStrokeStyle(2, 0x444444).setDepth(0);
            
            for (let r=0; r<8; r++) { this.grid[r] = []; for (let c=0; c<8; c++) this.spawnTile(r, c); }
        }

        spawnTile(r, c, fromTop = false) {
            const types = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
            let type = Phaser.Utils.Array.GetRandom(types);
            let tx = OFFSET_X + c * TILE_S + TILE_S/2;
            let ty = OFFSET_Y + r * TILE_S + TILE_S/2;
            
            let tile = this.add.image(tx, fromTop ? ty - 600 : ty, `tile_${type}`).setDisplaySize(64, 64).setInteractive().setDepth(5);
            // Тень для плитки
            tile.postFX.addShadow(0, 0, 0.05, 1, 0x000000, 12, 1);
            
            tile.gridR = r; tile.gridC = c; tile.type = type;
            tile.on('pointerdown', (p, x, y, e) => { 
                e.stopPropagation(); 
                this.handleTileClick(tile); 
            });
            this.grid[r][c] = tile;
            if (fromTop) this.tweens.add({ targets: tile, y: ty, duration: 400, ease: 'Bounce.Out' });
        }

        async handleTileClick(tile) {
            if (this.isAnimating || this.turn !== "PLAYER" || this.lootActive) return;
            if (!this.selectedTile) { 
                this.selectedTile = tile; 
                tile.setTint(0xffff00); 
                this.tweens.add({targets: tile, scale: 1.1, duration: 100, yoyo: true});
            } else {
                let dR = Math.abs(this.selectedTile.gridR - tile.gridR), dC = Math.abs(this.selectedTile.gridC - tile.gridC);
                if (dR + dC === 1) {
                    await this.swapTiles(this.selectedTile, tile);
                    if (!await this.checkMatches()) await this.swapTiles(this.selectedTile, tile);
                    else { this.turn = "MOB"; this.time.delayedCall(500, () => this.mobAI()); }
                }
                if(this.selectedTile) this.selectedTile.clearTint();
                this.selectedTile = null;
            }
        }

        async swapTiles(t1, t2) {
            this.isAnimating = true;
            let r1 = t1.gridR, c1 = t1.gridC, r2 = t2.gridR, c2 = t2.gridC;
            this.grid[r1][c1] = t2; this.grid[r2][c2] = t1;
            t1.gridR = r2; t1.gridC = c2; t2.gridR = r1; t2.gridC = c1;
            return new Promise(res => {
                this.tweens.add({ targets: t1, x: OFFSET_X + c2 * TILE_S + TILE_S/2, y: OFFSET_Y + r2 * TILE_S + TILE_S/2, duration: 200 });
                this.tweens.add({ targets: t2, x: OFFSET_X + c1 * TILE_S + TILE_S/2, y: OFFSET_Y + r1 * TILE_S + TILE_S/2, duration: 200, onComplete: () => { this.isAnimating = false; res(); } });
            });
        }

        async checkMatches() {
            let toRem = new Set();
            for(let r=0; r<8; r++) for(let c=0; c<6; c++) if(this.grid[r][c].type===this.grid[r][c+1].type && this.grid[r][c].type===this.grid[r][c+2].type) [0,1,2].forEach(i=>toRem.add(this.grid[r][c+i]));
            for(let c=0; c<8; c++) for(let r=0; r<6; r++) if(this.grid[r][c].type===this.grid[r+1][c].type && this.grid[r][c].type===this.grid[r+2][c].type) [0,1,2].forEach(i=>toRem.add(this.grid[r+i][c]));
            if (toRem.size > 0) { 
                toRem.forEach(t => { 
                    this.applyEffect(t.type); 
                    // Эффект взрыва
                    this.add.particles(t.x, t.y, `tile_${t.type}`, { speed: 100, scale: { start: 0.5, end: 0 }, lifespan: 300, quantity: 5 });
                    this.grid[t.gridR][t.gridC] = null; t.destroy(); 
                });
                await this.fillEmpty(); await this.checkMatches(); return true; 
            }
            return false;
        }

        async fillEmpty() {
            for(let c=0; c<8; c++) {
                let empty = 0;
                for(let r=7; r>=0; r--) { 
                    if(!this.grid[r][c]) empty++; 
                    else if(empty > 0) { 
                        let t = this.grid[r][c]; this.grid[r+empty][c] = t; this.grid[r][c] = null; t.gridR = r+empty; 
                        this.tweens.add({ targets: t, y: OFFSET_Y + t.gridR * TILE_S + TILE_S/2, duration: 300, ease: 'Bounce.Out' }); 
                    } 
                }
                for(let i=0; i<empty; i++) this.spawnTile(i, c, true);
            }
            await new Promise(res => this.time.delayedCall(300, res));
        }

        applyEffect(type, mult = 1) {
            let totalA = this.player.baseAtk + Object.values(this.player.equip).reduce((a, b) => a + (b.atk || 0), 0);
            if (type==='Red' || type==='Purple') { 
                let dmg = Math.floor((totalA/5) * mult); this.mob.hp -= dmg; this.addLog(`Атака: -${dmg}`, FONT_DMG); 
            }
            if (type==='Green') this.player.hp = Math.min(this.player.maxHp, this.player.hp + 15);
            if (type==='Blue') this.player.mana = Math.min(100, this.player.mana + 10);
            if (type==='Yellow') this.player.gold += 5;
            this.updateUI();
        }

        async mobAI() {
            if (this.mob.hp <= 0 || this.lootActive) return;
            
            // ИИ ищет ход
            let moveFound = false;
            for(let r=0; r<8; r++) { for(let c=0; c<7; c++) {
                let t1=this.grid[r][c], t2=this.grid[r][c+1];
                this.grid[r][c]=t2; this.grid[r][c+1]=t1;
                if(this.findM()) { 
                    this.grid[r][c]=t1; this.grid[r][c+1]=t2; // Возврат перед реальным ходом
                    await this.swapTiles(t1, t2); await this.checkMatches(); moveFound=true; break; 
                }
                this.grid[r][c]=t1; this.grid[r][c+1]=t2;
            } if(moveFound) break; }

            // Накопление маны и атака
            this.mob.mana += 20;
            let dmg = Math.max(5, this.mob.atk - this.player.arm);
            this.player.hp -= dmg;
            this.addLog(`Враг бьет: -${dmg}`, {color:'#ff4444'});

            if (this.mob.mana >= 100) {
                this.mob.mana = 0;
                this.addLog("ЯРОСТЬ ВРАГА!", {color:'#ff0000'});
                this.time.delayedCall(500, () => this.mobAI()); // Повторный ход
                return;
            }
            this.turn = "PLAYER"; this.updateUI();
        }
        
        findM() {
            for(let r=0; r<8; r++) for(let c=0; c<6; c++) if(this.grid[r][c].type===this.grid[r][c+1].type && this.grid[r][c].type===this.grid[r][c+2].type) return true;
            for(let c=0; c<8; c++) for(let r=0; r<6; r++) if(this.grid[r][c].type===this.grid[r+1][c].type && this.grid[r][c].type===this.grid[r+2][c].type) return true;
            return false;
        }

        generateLoot() {
            return { name: "Трофей", slot: "weapon", statType: "atk", label: "ATK", val: 5 + this.player.level, rarity: "Обычный", color: "#fff", price: 100 };
        }

        showLootWindow(loot) {
            this.lootActive = true;
            this.lootContainer = this.add.container(GW/2, GH/2).setDepth(2000);
            
            // Готическое окно (Рисуем)
            let w = this.drawGothicFrame(-250, -200, 500, 400);
            
            let t1 = this.add.text(0, -150, "ПОБЕДА!", FONT_HEADER).setOrigin(0.5);
            let t2 = this.add.text(0, -50, `${loot.rarity} ${loot.name}\n+${loot.val} ${loot.label}`, { fontFamily: 'Cinzel', fontSize: '24px', fill: loot.color, align: 'center' }).setOrigin(0.5);
            
            let btn1 = this.add.rectangle(-100, 100, 180, 60, 0x004400).setInteractive().setStrokeStyle(2, 0x00ff00);
            let txt1 = this.add.text(-100, 100, "ОДЕТЬ", FONT_MAIN).setOrigin(0.5);
            
            let btn2 = this.add.rectangle(100, 100, 180, 60, 0x440000).setInteractive().setStrokeStyle(2, 0xff0000);
            let txt2 = this.add.text(100, 100, "ПРОДАТЬ", FONT_MAIN).setOrigin(0.5);

            this.lootContainer.add([w, t1, t2, btn1, txt1, btn2, txt2]);

            btn1.on('pointerdown', (p,x,y,e) => { e.stopPropagation(); this.player.equip[loot.slot] = { n: loot.name, [loot.statType]: loot.val, label: loot.label }; this.closeLoot(); });
            btn2.on('pointerdown', (p,x,y,e) => { e.stopPropagation(); this.player.gold += loot.price; this.closeLoot(); });
        }

        closeLoot() { this.lootContainer.destroy(); this.player.level++; this.spawnMob(); this.updateUI(); this.lootActive = false; }

        async useUlt() {
             if(this.player.mana >= 100) { 
                 this.player.mana = 0; 
                 // Вспышка экрана
                 this.cameras.main.flash(500, 255, 255, 255);
                 this.mob.hp -= 200; 
                 this.updateUI(); 
             } 
        }

        addLog(m, s) {
            this.logTexts.unshift(this.logTexts.pop());
            this.logTexts[0].setText(m).setStyle(s || {fill:'#fff'}).setAlpha(0);
            this.tweens.add({ targets: this.logTexts[0], alpha: 1, duration: 300 });
            this.logTexts.forEach((t, i) => t.setY(800 + (i * 20)));
        }
    }

    new Phaser.Game({ type: Phaser.AUTO, parent: 'game-container', width: GW, height: GH, scene: [MainScene], backgroundColor: 'transparent' });
    </script>
</body>
</html>
