<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taverna War: Total Freeze</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        /* Убираем любые попытки браузера скроллить или выделять текст */
        body { 
            margin: 0; background: #0c0a08; 
            display: flex; justify-content: center; align-items: center; 
            height: 100vh; overflow: hidden; 
            touch-action: none; -webkit-touch-callout: none;
            -webkit-user-select: none; user-select: none;
        }
        canvas { border: 2px solid #b48c46; outline: none; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
    const GW = 1200, GH = 900, TILE_S = 70;
    const GRID_SIZE = 8 * TILE_S;
    const OFFSET_X = Math.floor((GW - GRID_SIZE) / 2);
    const OFFSET_Y = 175;

    class MainScene extends Phaser.Scene {
        constructor() { super('MainScene'); }

        preload() {
            this.load.image('hero_Воин', 'assets/hero_warrior.png');
            this.load.image('hero_Маг', 'assets/hero_mage.png');
            this.load.image('hero_Лучник', 'assets/hero_archer.png');
            this.load.image('hero_Ассасин', 'assets/hero_assassin.png');
            ['Red', 'Blue', 'Green', 'Purple', 'Yellow'].forEach(c => 
                this.load.image(`tile_${c}`, `assets/rune_${c.toLowerCase()}.png`)
            );
        }

        create() { this.showMenu(); }

        showMenu() {
            this.children.removeAll();
            this.add.text(GW/2, 100, "ВЫБЕРИТЕ ГЕРОЯ", { fontSize: '42px', fill: '#ffd700', fontStyle: 'bold' }).setOrigin(0.5);
            ["Воин", "Маг", "Лучник", "Ассасин"].forEach((name, i) => {
                let x = 300 * i + 150;
                let card = this.add.rectangle(x, 450, 260, 550, 0x1a1a1a).setInteractive().setStrokeStyle(2, 0xb48c46);
                this.add.text(x, 600, name, { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
                card.on('pointerdown', () => this.startGame(name));
            });
        }

        startGame(job) {
            this.children.removeAll();
            this.player = { job, maxHp: 1000, hp: 1000, mana: 0, level: 1, gold: 0, baseAtk: 30 };
            this.spawnMob();
            this.createStaticUI();
            this.initGrid();
            this.updateUI();

            // ГЛОБАЛЬНЫЙ ПЕРЕХВАТЧИК: Читаем клик, но фильтруем зоны
            this.input.on('pointerdown', (pointer) => {
                this.handleGlobalInput(pointer.x, pointer.y);
            });
        }

        createStaticUI() {
            // Рамки (Depth 1) - неинтерактивны по умолчанию
            this.add.rectangle(155, 450, 290, 860, 0x000000).setStrokeStyle(2, 0xb48c46).setDepth(1);
            this.add.rectangle(GW - 155, 450, 290, 860, 0x000000).setStrokeStyle(2, 0xb48c46).setDepth(1);
            
            this.hpText = this.add.text(35, 240, "", { fontSize: '19px', fill: '#ff4444' }).setDepth(2);
            this.manaText = this.add.text(35, 310, "", { fontSize: '19px', fill: '#4444ff' }).setDepth(2);
            this.goldText = this.add.text(35, 370, "", { fontSize: '24px', fill: '#ffd700' }).setDepth(2);
            this.hpBar = this.add.graphics().setDepth(2);
            this.manaBar = this.add.graphics().setDepth(2);
            
            // Кнопка Ульты (Depth 2)
            this.ultZone = new Phaser.Geom.Rectangle(35, 410, 240, 60);
            this.add.rectangle(155, 440, 240, 60, 0x440044).setStrokeStyle(2, 0xff00ff).setDepth(2);
            this.add.text(155, 440, "СУПЕРУДАР", { fontSize: '22px' }).setOrigin(0.5).setDepth(2);

            this.mobHpText = this.add.text(GW - 155, 260, "", { fontSize: '26px', fill: '#ff0000' }).setOrigin(0.5).setDepth(2);
            this.mobHpBar = this.add.graphics().setDepth(2);
        }

        handleGlobalInput(x, y) {
            // 1. Если открыт лут - проверяем ТОЛЬКО кнопку "Продолжить"
            if (this.lootActive) {
                if (x > GW/2 - 100 && x < GW/2 + 100 && y > GH/2 + 50 && y < GH/2 + 110) {
                    this.closeLoot();
                }
                return; // Игнорируем всё остальное
            }

            // 2. Проверяем зону ульты
            if (this.ultZone.contains(x, y)) {
                this.useUlt();
                return;
            }

            // 3. Проверяем зону плиток
            let c = Math.floor((x - OFFSET_X) / TILE_S);
            let r = Math.floor((y - OFFSET_Y) / TILE_S);

            if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                let tile = this.grid[r][c];
                if (tile) this.handleTileClick(tile);
            }
            // 4. КЛИК В ЛЮБОЕ ДРУГОЕ МЕСТО ПРОСТО ИГНОРИРУЕТСЯ
        }

        updateUI() {
            this.hpText.setText(`HP: ${Math.floor(this.player.hp)} / ${this.player.maxHp}`);
            this.manaText.setText(`MANA: ${this.player.mana}%`);
            this.goldText.setText(`GOLD: ${this.player.gold}`);
            this.mobHpText.setText(`МОНСТР\nHP: ${Math.floor(this.mob.hp)}`);

            this.hpBar.clear().fillStyle(0x330000).fillRect(35, 275, 240, 15).fillStyle(0xff0000).fillRect(35, 275, (this.player.hp/this.player.maxHp)*240, 15);
            this.manaBar.clear().fillStyle(0x000033).fillRect(35, 335, 240, 15).fillStyle(0x4444ff).fillRect(35, 335, (this.player.mana/100)*240, 15);
            this.mobHpBar.clear().fillStyle(0x330000).fillRect(GW - 275, 290, 240, 15).fillStyle(0xff0000).fillRect(GW - 275, 290, (Math.max(0, this.mob.hp)/this.mob.maxHp)*240, 15);
            
            if(this.mob.hp <= 0 && !this.lootActive) this.showLootWindow();
        }

        // Остальная логика (initGrid, swapTiles, checkMatches) остается прежней, 
        // но теперь плитки НЕ имеют собственных событий 'pointerdown'
        initGrid() {
            this.grid = []; this.isAnimating = false;
            for (let r=0; r<8; r++) { 
                this.grid[r] = []; 
                for (let c=0; c<8; c++) this.spawnTile(r, c); 
            }
        }

        spawnTile(r, c, fromTop = false) {
            const types = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
            let type = Phaser.Utils.Array.GetRandom(types);
            let tx = OFFSET_X + c * TILE_S + TILE_S/2;
            let ty = OFFSET_Y + r * TILE_S + TILE_S/2;
            let tile = this.add.image(tx, fromTop ? ty - 600 : ty, `tile_${type}`).setDisplaySize(64, 64).setDepth(3);
            tile.gridR = r; tile.gridC = c; tile.type = type;
            this.grid[r][c] = tile;
            if (fromTop) this.tweens.add({ targets: tile, y: ty, duration: 300 });
        }

        async handleTileClick(tile) {
            if (this.isAnimating || this.turn !== "PLAYER") return;
            if (!this.selectedTile) { 
                this.selectedTile = tile; tile.setTint(0xffff00); 
            } else {
                let dR = Math.abs(this.selectedTile.gridR - tile.gridR), dC = Math.abs(this.selectedTile.gridC - tile.gridC);
                if (dR + dC === 1) {
                    await this.swapTiles(this.selectedTile, tile);
                    if (!await this.checkMatches()) await this.swapTiles(this.selectedTile, tile);
                    else { this.turn = "MOB"; this.time.delayedCall(400, () => this.mobAI()); }
                }
                if(this.selectedTile) this.selectedTile.clearTint();
                this.selectedTile = null;
            }
        }

        async swapTiles(t1, t2) {
            this.isAnimating = true;
            let r1 = t1.gridR, c1 = t1.gridC, r2 = t2.gridR, c2 = t2.gridC;
            this.grid[r1][c1] = t2; this.grid[r2][c2] = t1;
            t1.gridR = r2; t1.gridC = c2; t2.gridR = r1; t2.gridC = c1;
            return new Promise(res => {
                this.tweens.add({ targets: t1, x: OFFSET_X+c2*TILE_S+TILE_S/2, y: OFFSET_Y+r2*TILE_S+TILE_S/2, duration: 200 });
                this.tweens.add({ targets: t2, x: OFFSET_X+c1*TILE_S+TILE_S/2, y: OFFSET_Y+r1*TILE_S+TILE_S/2, duration: 200, onComplete: () => { this.isAnimating = false; res(); } });
            });
        }

        async checkMatches() {
            let toRem = new Set();
            for(let r=0; r<8; r++) for(let c=0; c<6; c++) {
                if(this.grid[r][c] && this.grid[r][c+1] && this.grid[r][c+2] && this.grid[r][c].type === this.grid[r][c+1].type && this.grid[r][c].type === this.grid[r][c+2].type)
                    [this.grid[r][c], this.grid[r][c+1], this.grid[r][c+2]].forEach(t => toRem.add(t));
            }
            for(let c=0; c<8; c++) for(let r=0; r<6; r++) {
                if(this.grid[r][c] && this.grid[r+1][c] && this.grid[r+2][c] && this.grid[r][c].type === this.grid[r+1][c].type && this.grid[r][c].type === this.grid[r+2][c].type)
                    [this.grid[r][c], this.grid[r+1][c], this.grid[r+2][c]].forEach(t => toRem.add(t));
            }
            if (toRem.size > 0) {
                toRem.forEach(t => { this.applyEffect(t.type); this.grid[t.gridR][t.gridC] = null; t.destroy(); });
                await this.fillEmpty(); await this.checkMatches(); return true;
            }
            return false;
        }

        async fillEmpty() {
            for(let c=0; c<8; c++) {
                let empty = 0;
                for(let r=7; r>=0; r--) {
                    if(!this.grid[r][c]) empty++;
                    else if(empty > 0) {
                        let t = this.grid[r][c]; this.grid[r+empty][c] = t; this.grid[r][c] = null; t.gridR = r+empty;
                        this.tweens.add({ targets: t, y: OFFSET_Y + t.gridR * TILE_S + TILE_S/2, duration: 200 });
                    }
                }
                for(let i=0; i<empty; i++) this.spawnTile(i, c, true);
            }
            await new Promise(res => this.time.delayedCall(250, res));
        }

        applyEffect(type) {
            if (type==='Red' || type==='Purple') this.mob.hp -= 20;
            if (type==='Green') this.player.hp = Math.min(this.player.maxHp, this.player.hp + 15);
            if (type==='Blue') this.player.mana = Math.min(100, this.player.mana + 10);
            if (type==='Yellow') this.player.gold += 5;
            this.updateUI();
        }

        spawnMob() {
            this.mob = { hp: 200, maxHp: 200, atk: 20 };
            this.turn = "PLAYER"; this.lootActive = false;
        }

        showLootWindow() {
            this.lootActive = true;
            this.lootContainer = this.add.container(GW/2, GH/2).setDepth(1000);
            let bg = this.add.rectangle(0, 0, 400, 250, 0x000000, 0.9).setStrokeStyle(3, 0xffd700);
            let btn = this.add.rectangle(0, 70, 180, 50, 0x006600).setStrokeStyle(2, 0xffffff);
            this.lootContainer.add([bg, this.add.text(0, -40, "ПОБЕДА!", {fontSize:'32px'}).setOrigin(0.5), btn, this.add.text(0, 70, "ДАЛЕЕ").setOrigin(0.5)]);
        }

        closeLoot() {
            this.lootActive = false;
            this.lootContainer.destroy(); 
            this.player.level++; this.spawnMob(); this.updateUI();
        }

        mobAI() {
            if (this.mob.hp > 0) { this.player.hp -= this.mob.atk; this.updateUI(); }
            this.turn = "PLAYER";
        }

        useUlt() { if (this.player.mana >= 100) { this.player.mana = 0; this.mob.hp -= 100; this.updateUI(); } }
    }

    new Phaser.Game({ type: Phaser.AUTO, parent: 'game-container', width: GW, height: GH, scene: [MainScene], backgroundColor: '#0c0a08' });
    </script>
</body>
</html>
