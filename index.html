<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taverna War</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #0c0a08; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
    const GW = 1200, GH = 900, OFFSET_X = 400, OFFSET_Y = 140, TILE_S = 68;

    class MainScene extends Phaser.Scene {
        constructor() { super('MainScene'); }

        preload() {
            // ПУТИ ИСПРАВЛЕНЫ СОГЛАСНО СКРИНШОТУ (папка assets)
            const heroes = { 'Воин': 'assets/hero_warrior.png', 'Маг': 'assets/hero_mage.png', 'Лучник': 'assets/hero_archer.png', 'Ассасин': 'assets/hero_assassin.png' };
            for (let name in heroes) this.load.image(`hero_${name}`, heroes[name]);

            const runes = { 'Red': 'assets/rune_red.png', 'Blue': 'assets/rune_blue.png', 'Green': 'assets/rune_green.png', 'Purple': 'assets/rune_purple.png', 'Yellow': 'assets/rune_yellow.png' };
            for (let color in runes) this.load.image(`tile_${color}`, runes[color]);
        }

        create() { this.showMenu(); }

        showMenu() {
            this.children.removeAll();
            this.add.text(GW/2, 100, "ВЫБЕРИТЕ ГЕРОЯ", { fontSize: '42px', fill: '#ffd700', fontStyle: 'bold' }).setOrigin(0.5);
            const jobs = ["Воин", "Маг", "Лучник", "Ассасин"];
            jobs.forEach((name, i) => {
                let x = 300 * i + 150;
                let card = this.add.rectangle(x, 450, 260, 500, 0x1a1a1a).setInteractive().setStrokeStyle(2, 0xb48c46);
                this.add.image(x, 400, `hero_${name}`).setDisplaySize(180, 180);
                this.add.text(x, 600, name, { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
                card.on('pointerdown', () => this.startGame(name));
            });
        }

        startGame(job) {
            this.children.removeAll();
            const hps = { "Воин": 1400, "Маг": 720, "Лучник": 880, "Ассасин": 800 };
            this.player = {
                job, hp: hps[job], maxHp: hps[job], mana: 0, gold: 0, level: 1, baseAtk: 45, shield: 0, combo: 1,
                stats: { atk: 0, def: 0, hpBonus: 0, manaGain: 1.0 },
                equip: { head: null, body: null, legs: null, ring: null, amulet: null, weapon: null }
            };
            this.spawnMob();
            this.initGrid();
            this.createUI();
            this.updateUI();
        }

        spawnMob() {
            let lvl = this.player.level;
            let isBoss = lvl % 5 === 0;
            this.mob = { 
                name: isBoss ? "БОСС УР. " + lvl : "МОНСТР УР. " + lvl, 
                maxHp: (150 + (lvl*120)) * (isBoss ? 2.5 : 1), 
                hp: (150 + (lvl*120)) * (isBoss ? 2.5 : 1), 
                atk: 15 + (lvl*10), 
                isBoss 
            };
            this.turn = "PLAYER";
            this.lootActive = false;
        }

        async executeUlt() {
            if (this.player.mana < 100 || this.isAnimating) return;
            this.player.mana = 0;
            this.isAnimating = true;
            let toRemove = [];

            if (this.player.job === "Воин") {
                this.grid.flat().forEach(t => { if(t && (t.type === 'Red' || t.type === 'Green')) toRemove.push(t); });
            } else if (this.player.job === "Маг") {
                this.player.shield = Math.floor(this.player.hp * 0.20);
                this.grid.flat().forEach(t => { if(t && (t.type === 'Purple' || t.type === 'Yellow')) toRemove.push(t); });
            } else if (this.player.job === "Лучник") {
                let rows = Phaser.Utils.Array.NumberArray(0, 7);
                Phaser.Utils.Array.Shuffle(rows).slice(0, 4).forEach(r => {
                    for(let c=0; c<8; c++) if(this.grid[r][c]) toRemove.push(this.grid[r][c]);
                });
            } else if (this.player.job === "Ассасин") {
                let all = this.grid.flat().filter(t => t !== null);
                toRemove = Phaser.Utils.Array.Shuffle(all).slice(0, Math.floor(all.length * 0.3));
                this.mob.hp -= (this.player.baseAtk + this.player.stats.atk);
            }

            // ЭФФЕКТ: ОТ ТУСКЛОГО К ЯРКО-БЕЛОМУ
            toRemove.forEach(t => {
                if(t) {
                    this.tweens.add({
                        targets: t,
                        tint: 0xffffff,
                        alpha: 1,
                        scale: 1.3,
                        duration: 500,
                        ease: 'Quad.easeIn'
                    });
                }
            });

            this.time.delayedCall(600, async () => {
                toRemove.forEach(t => { if(t) { this.applyEffect(t.type); this.grid[t.gridR][t.gridC] = null; t.destroy(); }});
                await this.fillEmpty();
                this.isAnimating = false;
                this.updateUI();
                this.time.delayedCall(400, () => this.mobAI());
            });
        }

        initGrid() {
            this.grid = [];
            for (let r=0; r<8; r++) { this.grid[r]=[]; for (let c=0; c<8; c++) this.spawnTile(r, c); }
        }

        spawnTile(r, c, fromTop = false) {
            const types = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
            let type = Phaser.Utils.Array.GetRandom(types);
            let tx = OFFSET_X+c*TILE_S, ty = OFFSET_Y+r*TILE_S;
            let tile = this.add.image(tx, fromTop ? ty-500 : ty, `tile_${type}`).setDisplaySize(62,62).setInteractive().setDepth(2);
            tile.gridR = r; tile.gridC = c; tile.type = type;
            tile.on('pointerdown', () => { if(!this.lootActive) this.handleTileClick(tile); });
            this.grid[r][c] = tile;
            if (fromTop) this.tweens.add({ targets: tile, y: ty, duration: 400 });
        }

        async handleTileClick(tile) {
            if (this.isAnimating || this.turn !== "PLAYER") return;
            if (!this.selectedTile) { this.selectedTile = tile; tile.setTint(0xffff00); }
            else {
                let dR = Math.abs(this.selectedTile.gridR - tile.gridR), dC = Math.abs(this.selectedTile.gridC - tile.gridC);
                if (dR + dC === 1) {
                    await this.swapTiles(this.selectedTile, tile);
                    this.player.combo = 1;
                    if (!await this.checkMatches()) await this.swapTiles(this.selectedTile, tile);
                    else { this.turn = "MOB"; this.time.delayedCall(600, () => this.mobAI()); }
                }
                if (this.selectedTile) this.selectedTile.clearTint();
                this.selectedTile = null;
            }
        }

        async swapTiles(t1, t2) {
            this.isAnimating = true;
            let r1=t1.gridR, c1=t1.gridC, r2=t2.gridR, c2=t2.gridC;
            this.grid[r1][c1]=t2; this.grid[r2][c2]=t1;
            t1.gridR=r2; t1.gridC=c2; t2.gridR=r1; t2.gridC=c1;
            return new Promise(res => {
                this.tweens.add({ targets: t1, x: OFFSET_X+c2*TILE_S, y: OFFSET_Y+r2*TILE_S, duration: 200 });
                this.tweens.add({ targets: t2, x: OFFSET_X+c1*TILE_S, y: OFFSET_Y+r1*TILE_S, duration: 200, onComplete: () => { this.isAnimating = false; res(); } });
            });
        }

        async checkMatches() {
            let toRem = new Set();
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    if(c<6 && this.grid[r][c] && this.grid[r][c+1] && this.grid[r][c+2] && this.grid[r][c].type === this.grid[r][c+1].type && this.grid[r][c].type === this.grid[r][c+2].type) {
                        [0,1,2].forEach(i => toRem.add(this.grid[r][c+i]));
                        if(c<5 && this.grid[r][c+3] && this.grid[r][c].type === this.grid[r][c+3].type) for(let i=0; i<8; i++) if(this.grid[r][i]) toRem.add(this.grid[r][i]);
                    }
                    if(r<6 && this.grid[r][c] && this.grid[r+1][c] && this.grid[r+2][c] && this.grid[r][c].type === this.grid[r+1][c].type && this.grid[r][c].type === this.grid[r+2][c].type) {
                        [0,1,2].forEach(i => toRem.add(this.grid[r+i][c]));
                        if(r<5 && this.grid[r+3][c] && this.grid[r][c].type === this.grid[r+3][c].type) for(let i=0; i<8; i++) if(this.grid[i][c]) toRem.add(this.grid[i][c]);
                    }
                }
            }
            if (toRem.size > 0) { 
                toRem.forEach(t => { if(t) { this.applyEffect(t.type); this.grid[t.gridR][t.gridC] = null; t.destroy(); }});
                await this.fillEmpty(); this.player.combo *= 1.15; await this.checkMatches(); return true; 
            }
            return false;
        }

        async fillEmpty() {
            for(let c=0; c<8; c++) {
                let empty = 0;
                for(let r=7; r>=0; r--) { 
                    if(!this.grid[r][c]) empty++; 
                    else if(empty > 0) { 
                        let t = this.grid[r][c]; this.grid[r+empty][c] = t; this.grid[r][c] = null; t.gridR = r+empty; 
                        this.tweens.add({ targets: t, y: OFFSET_Y+t.gridR*TILE_S, duration: 250 }); 
                    } 
                }
                for(let i=0; i<empty; i++) this.spawnTile(i, c, true);
            }
            await new Promise(res => this.time.delayedCall(300, res));
        }

        applyEffect(type) {
            let atk = (this.player.baseAtk + this.player.stats.atk) * this.player.combo;
            if (type === 'Red' || type === 'Purple') {
                let d = Math.floor(atk/10);
                this.mob.hp -= d;
                this.addLog(`УРОН: -${d}`, '#ffcc00');
            }
            if (type === 'Green') {
                let h = Math.floor(15 * this.player.combo);
                this.player.hp = Math.min(this.player.maxHp + this.player.stats.hpBonus, this.player.hp + h);
                this.addLog(`ЛЕЧЕНИЕ: +${h}`, '#00ff00');
            }
            if (type === 'Blue') this.player.mana = Math.min(100, this.player.mana + (6 * this.player.stats.manaGain));
            if (type === 'Yellow') this.player.gold += 2;
            this.updateUI();
        }

        async mobAI() {
            if (this.mob.hp <= 0 || this.lootActive) return;
            let dmg = Math.max(5, this.mob.atk - this.player.stats.def);
            if (this.player.shield > 0) { let p = Math.min(this.player.shield, dmg); this.player.shield -= p; dmg -= p; }
            this.player.hp -= dmg;
            this.addLog(`МОНСТР: -${dmg} ХП`, '#ff0000');
            this.turn = "PLAYER"; this.updateUI();
        }

        createUI() {
            this.add.rectangle(0,0,366,GH,0x111111).setOrigin(0).setStrokeStyle(2, 0xb48c46);
            this.add.rectangle(910,0,290,GH,0x111111).setOrigin(0).setStrokeStyle(2, 0xb48c46);
            
            this.pImg = this.add.image(183, 100, `hero_${this.player.job}`).setDisplaySize(160, 160);
            this.hpBar = this.add.graphics();
            this.manaBar = this.add.graphics();
            this.hpTxt = this.add.text(40, 190, "", {fontSize: '20px', fill: '#ff4444', fontStyle: 'bold'});
            this.manaTxt = this.add.text(40, 235, "", {fontSize: '20px', fill: '#4444ff', fontStyle: 'bold'});
            
            this.invTxts = {};
            const slots = { head: "ГОЛОВА", body: "ТЕЛО", legs: "НОГИ", ring: "КОЛЬЦО", amulet: "АМУЛЕТ", weapon: "ОРУЖИЕ" };
            Object.keys(slots).forEach((s, i) => {
                this.invTxts[s] = this.add.text(30, 290 + (i*35), "", {fontSize: '16px', fill: '#666'});
                this.invTxts[s].label = slots[s];
            });

            this.ultBtn = this.add.rectangle(183, 560, 260, 60, 0x440044).setInteractive().setStrokeStyle(2, 0xff00ff);
            this.add.text(183, 560, "УЛЬТА", {fontSize: '26px', fontStyle: 'bold'}).setOrigin(0.5);
            this.ultBtn.on('pointerdown', () => this.executeUlt());

            this.mHpBar = this.add.graphics();
            this.mTxt = this.add.text(1055, 200, "", {fontSize: '20px', fill: '#ff0000', align: 'center'}).setOrigin(0.5);
            
            this.logTexts = [];
            for (let i=0; i<6; i++) this.logTexts.push(this.add.text(GW/2, 750 + (i*22), "", {fontSize: '18px'}).setOrigin(0.5));
        }

        updateUI() {
            let max = this.player.maxHp + this.player.stats.hpBonus;
            this.hpBar.clear().fillStyle(0x330000).fillRect(40, 215, 280, 18).fillStyle(0xff0000).fillRect(40, 215, (Math.max(0,this.player.hp)/max)*280, 18);
            this.manaBar.clear().fillStyle(0x000033).fillRect(40, 260, 280, 18).fillStyle(0x4444ff).fillRect(40, 260, (this.player.mana/100)*280, 18);
            this.hpTxt.setText(`ХП: ${Math.floor(this.player.hp)} / ${max}`);
            this.manaTxt.setText(`УЛЬТА: ${Math.floor(this.player.mana)}%`);
            
            for(let k in this.invTxts) {
                let e = this.player.equip[k];
                this.invTxts[k].setText(`${this.invTxts[k].label}: ${e ? e.gradeName+' (А:'+e.atk+' З:'+e.def+')' : '---'}`).setFill(e ? e.color : '#666');
            }

            this.mTxt.setText(`${this.mob.name}\nHP: ${Math.floor(this.mob.hp)}`);
            this.mHpBar.clear().fillStyle(0x330000).fillRect(930, 230, 250, 18).fillStyle(0xff0000).fillRect(930, 230, (Math.max(0,this.mob.hp)/this.mob.maxHp)*250, 18);

            if (this.mob.hp <= 0 && !this.lootActive) this.showLoot();
            if (this.player.hp <= 0) location.reload();
        }

        showLoot() {
            this.lootActive = true;
            const grades = [{n:'Обычный',c:'#fff',s:1,ch:60},{n:'Редкий',c:'#0088ff',s:2,ch:30},{n:'Эпик',c:'#a020f0',s:3,ch:10}];
            let g = this.mob.isBoss ? {n:'ЛЕГЕНДА',c:'#ffd700',s:3} : grades[Phaser.Math.RND.weightedPick([0,1,2].map(i=>grades[i].ch))];
            let slot = Phaser.Utils.Array.GetRandom(['head','body','legs','ring','amulet','weapon']);
            let item = { slot, gradeName: g.n, color: g.c, atk:0, def:0, hp:0, speed:0 };
            for(let i=0; i<g.s; i++) {
                let st = Phaser.Utils.Array.GetRandom(['atk','def','hp','speed']);
                item[st] += Math.floor(this.player.level * (st==='hp'?20:5));
            }

            this.lootBox = this.add.container(GW/2, GH/2).setDepth(1000);
            let bg = this.add.rectangle(0, 0, 500, 400, 0x000, 0.95).setStrokeStyle(4, 0xb48c46);
            let info = `[${item.gradeName}] ${slot.toUpperCase()}\nАТК:${item.atk} ЗАЩ:${item.def} HP:${item.hp} СКР:${item.speed}`;
            this.lootBox.add([bg, this.add.text(0, -150, "ТРОФЕЙ!", {fontSize: '32px', fill: '#ffd700'}).setOrigin(0.5), this.add.text(0, -20, info, {fontSize: '22px', align: 'center', fill: item.color}).setOrigin(0.5)]);
            
            let b1 = this.add.rectangle(-120, 120, 180, 60, 0x008800).setInteractive();
            this.add.text(-120, 120, "ОДЕТЬ").setOrigin(0.5);
            let b2 = this.add.rectangle(120, 120, 180, 60, 0x880000).setInteractive();
            this.add.text(120, 120, "ПРОДАТЬ").setOrigin(0.5);

            this.lootBox.add([b1, b2]);
            b1.on('pointerdown', () => { this.player.equip[slot] = item; this.recalcStats(); this.closeLoot(); });
            b2.on('pointerdown', () => { this.player.gold += (this.player.level*15); this.closeLoot(); });
        }

        recalcStats() {
            let p = this.player;
            p.stats = { atk: 0, def: 0, hpBonus: 0, manaGain: 1.0 };
            Object.values(p.equip).forEach(e => { if(e) { p.stats.atk+=e.atk; p.stats.def+=e.def; p.stats.hpBonus+=e.hp; p.stats.manaGain+=(e.speed*0.01); }});
        }

        closeLoot() { this.player.level++; this.lootBox.destroy(); this.spawnMob(); this.updateUI(); }

        addLog(m, c) {
            this.logTexts.unshift(this.logTexts.pop());
            this.logTexts[0].setText(m).setFill(c);
            this.logTexts.forEach((t, i) => t.setAlpha(1 - i*0.15));
        }
    }

    new Phaser.Game({ type: Phaser.AUTO, parent: 'game-container', width: GW, height: GH, scene: [MainScene] });
    </script>
</body>
</html>
