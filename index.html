<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taverna War RPG - Full Logic</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #0c0a08; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { touch-action: none; border: 2px solid #b48c46; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
    const isMobile = window.innerWidth < 600;
    const GW = 1000;
    const GH = isMobile ? 1600 : 900;
    const TILE_SIZE = isMobile ? 110 : 80;
    const OFFSET_X = isMobile ? 115 : 450;
    const OFFSET_Y = isMobile ? 650 : 150;

    const config = {
        type: Phaser.AUTO, parent: 'game-container',
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: GW, height: GH },
        scene: { preload: preload, create: create, update: update }
    };

    const game = new Phaser.Game(config);
    let player, mob, grid = [], selectedTile = null, isAnimating = false;
    let hpBar, manaBar, mobHpBar, goldText, logText;

    function preload() {
        this.load.image('hero_Воин', 'assets/hero_warrior.png');
        const runes = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
        runes.forEach(r => this.load.image(`tile_${r}`, `assets/rune_${r.toLowerCase()}.png`));
    }

    function create() {
        player = { hp: 300, maxHp: 300, mana: 0, gold: 0, atk: 25, job: 'Воин' };
        mob = { name: "Орк-Тиран", hp: 150, maxHp: 150, atk: 15 };

        // Фон интерфейса
        this.add.graphics().fillStyle(0x191614, 1).fillRoundedRect(isMobile ? 50 : 20, 20, isMobile ? 900 : 310, isMobile ? 400 : 860, 20);
        this.add.image(isMobile ? 220 : 175, isMobile ? 250 : 450, 'hero_Воин').setDisplaySize(200, 200);
        
        goldText = this.add.text(isMobile ? 400 : 40, 50, `Золото: 0`, { fontSize: '32px', fill: '#ffd700' });
        logText = this.add.text(isMobile ? 100 : 380, isMobile ? 560 : 820, "Собери 3 в ряд!", { fontSize: '24px', fill: '#b4aa96' });

        // Бары
        hpBar = this.add.graphics();
        manaBar = this.add.graphics();
        mobHpBar = this.add.graphics();

        createGrid(this);
        
        // Кнопка Ульты
        let uBtn = this.add.rectangle(isMobile ? 500 : 175, isMobile ? 1500 : 800, isMobile ? 800 : 250, 100, 0x4a0e0e).setInteractive();
        this.add.text(uBtn.x, uBtn.y, "УЛЬТА (S)", { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
        uBtn.on('pointerdown', () => useUltimate(this));
        this.input.keyboard.on('keydown-S', () => useUltimate(this));

        updateUI();
    }

    function createGrid(scene) {
        const types = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
        for (let r = 0; r < 8; r++) {
            grid[r] = [];
            for (let c = 0; c < 8; c++) {
                spawnTile(r, c, scene);
            }
        }
    }

    function spawnTile(r, c, scene) {
        const types = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
        let type = Phaser.Utils.Array.GetRandom(types);
        let x = OFFSET_X + c * (TILE_SIZE + 5);
        let y = OFFSET_Y + r * (TILE_SIZE + 5);
        let tile = scene.add.image(x, y, `tile_${type}`).setInteractive().setDisplaySize(TILE_SIZE, TILE_SIZE);
        tile.gridR = r; tile.gridC = c; tile.type = type;
        tile.on('pointerdown', () => handleTileClick(tile, scene));
        grid[r][c] = tile;
    }

    async function handleTileClick(tile, scene) {
        if (isAnimating) return;
        if (!selectedTile) {
            selectedTile = tile;
            tile.setTint(0xaaaaaa);
        } else {
            let dR = Math.abs(selectedTile.gridR - tile.gridR);
            let dC = Math.abs(selectedTile.gridC - tile.gridC);
            if ((dR === 1 && dC === 0) || (dR === 0 && dC === 1)) {
                await swapTiles(selectedTile, tile, scene);
                if (!checkMatches(scene)) {
                    await swapTiles(selectedTile, tile, scene); // Возврат если нет совпадений
                } else {
                    handleTurn(scene);
                }
            }
            selectedTile.clearTint();
            selectedTile = null;
        }
    }

    function swapTiles(t1, t2, scene) {
        return new Promise(resolve => {
            isAnimating = true;
            let r1 = t1.gridR, c1 = t1.gridC;
            let r2 = t2.gridR, c2 = t2.gridC;
            grid[r1][c1] = t2; grid[r2][c2] = t1;
            t1.gridR = r2; t1.gridC = c2;
            t2.gridR = r1; t2.gridC = c1;

            scene.tweens.add({
                targets: t1, x: OFFSET_X + c2*(TILE_SIZE+5), y: OFFSET_Y + r2*(TILE_SIZE+5), duration: 200
            });
            scene.tweens.add({
                targets: t2, x: OFFSET_X + c1*(TILE_SIZE+5), y: OFFSET_Y + r1*(TILE_SIZE+5), duration: 200,
                onComplete: () => { isAnimating = false; resolve(); }
            });
        });
    }

    function checkMatches(scene) {
        let toRemove = new Set();
        // Горизонтальные
        for(let r=0; r<8; r++) {
            for(let c=0; c<6; c++) {
                if(grid[r][c].type === grid[r][c+1].type && grid[r][c].type === grid[r][c+2].type) {
                    toRemove.add(grid[r][c]); toRemove.add(grid[r][c+1]); toRemove.add(grid[r][c+2]);
                }
            }
        }
        // Вертикальные
        for(let c=0; c<8; c++) {
            for(let r=0; r<6; r++) {
                if(grid[r][c].type === grid[r+1][c].type && grid[r][c].type === grid[r+2][c].type) {
                    toRemove.add(grid[r][c]); toRemove.add(grid[r+1][c]); toRemove.add(grid[r+2][c]);
                }
            }
        }

        if(toRemove.size > 0) {
            toRemove.forEach(t => {
                triggerEffect(t.type);
                t.destroy();
                grid[t.gridR][t.gridC] = null;
            });
            fillGrid(scene);
            return true;
        }
        return false;
    }

    function triggerEffect(type) {
        if (type === 'Red') mob.hp -= Math.floor(player.atk / 2);
        if (type === 'Purple') mob.hp -= player.atk;
        if (type === 'Green') player.hp = Math.min(player.maxHp, player.hp + 15);
        if (type === 'Blue') player.mana = Math.min(100, player.mana + 10);
        if (type === 'Yellow') player.gold += 10;
        updateUI();
    }

    function fillGrid(scene) {
        for (let c = 0; c < 8; c++) {
            for (let r = 7; r >= 0; r--) {
                if (grid[r][c] === null) {
                    spawnTile(r, c, scene);
                }
            }
        }
        setTimeout(() => checkMatches(scene), 300);
    }

    function useUltimate(scene) {
        if (player.mana < 100) return;
        player.mana = 0;
        mob.hp -= 200;
        logText.setText("УЛЬТА: ВЗРЫВ КРОВИ!");
        updateUI();
    }

    function updateUI() {
        hpBar.clear().fillStyle(0x3c0000).fillRect(isMobile?400:40, 120, 300, 30).fillStyle(0xdc2828).fillRect(isMobile?400:40, 120, (player.hp/player.maxHp)*300, 30);
        manaBar.clear().fillStyle(0x141464).fillRect(isMobile?400:40, 160, 300, 15).fillStyle(0x2878ff).fillRect(isMobile?400:40, 160, (player.mana/100)*300, 15);
        mobHpBar.clear().fillStyle(0x3c0000).fillRect(isMobile?100:600, 80, 800, 30).fillStyle(0xff0000).fillRect(isMobile?100:600, 80, (Math.max(0, mob.hp)/mob.maxHp)*800, 30);
        goldText.setText(`Золото: ${player.gold}`);
        if(mob.hp <= 0) { mob.hp = mob.maxHp; player.gold += 100; logText.setText("Победа! Новый моб."); }
    }

    function update() {}
    </script>
</body>
</html>
