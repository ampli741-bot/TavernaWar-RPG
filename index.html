const GW = 1200, GH = 900, OFFSET_X = 400, OFFSET_Y = 140, TILE_S = 68;

class MainScene extends Phaser.Scene {
    constructor() { super('MainScene'); }

    // ==========================================
    // 1. ЗАГРУЗКА РЕСУРСОВ
    // ==========================================
    preload() {
        this.load.image('hero_Воин', 'assets/hero_warrior.png');
        this.load.image('hero_Маг', 'assets/hero_mage.png');
        this.load.image('hero_Лучник', 'assets/archer.png');
        this.load.image('hero_Ассасин', 'assets/assasin.png');
        this.load.image('mob_icon', 'assets/hero_warrior.png');
        ['Red', 'Blue', 'Green', 'Purple', 'Yellow'].forEach(c => 
            this.load.image(`tile_${c}`, `assets/rune_${c.toLowerCase()}.png`)
        );
    }

    create() { this.showMenu(); }

    // ==========================================
    // 2. ЛОГИКА ПЕРСОНАЖЕЙ И МОБОВ
    // ==========================================
    initPlayerData(job) {
        const hps = { "Воин": 1400, "Маг": 720, "Лучник": 880, "Ассасин": 800 };
        this.player = {
            job, maxHp: hps[job], hp: hps[job], arm: 0, mana: 0, gold: 0, level: 1, baseAtk: 25,
            equip: {
                head: { n: "Шлем", atk: 0, arm: 2 },
                body: { n: "Броня", atk: 0, arm: 5 },
                legs: { n: "Сапоги", atk: 0, arm: 2 },
                weapon: { n: "Меч", atk: 12, arm: 0 },
                ring: { n: "Кольцо", atk: 2, arm: 0 },
                neck: { n: "Амулет", atk: 0, arm: 0 }
            }
        };
        this.player.arm = Object.values(this.player.equip).reduce((a, b) => a + (b.arm || 0), 0);
    }

    spawnMob() {
        let lvl = this.player.level;
        this.mob = { 
            name: "Монстр Ур." + lvl, 
            maxHp: 100 + (lvl * 60), 
            hp: 100 + (lvl * 60), 
            atk: 15 + (lvl * 10)
        };
        this.turn = "PLAYER";
        this.lootActive = false; 
    }

    // ==========================================
    // 3. СУПЕРУДАРЫ (УЛЬТА)
    // ==========================================
    async useUlt() {
        if (this.player.mana < 100 || this.isAnimating) return;
        this.player.mana = 0;
        this.isAnimating = true;

        let targets = [];
        for(let r=0; r<8; r++) {
            for(let c=0; c<8; c++) {
                let t = this.grid[r][c];
                if (this.player.job === "Воин" && (t.type === 'Red' || t.type === 'Green')) targets.push(t);
                if (this.player.job === "Маг" && (t.type === 'Purple' || t.type === 'Yellow')) targets.push(t);
                if (this.player.job === "Лучник" && (t.type === 'Red' || t.type === 'Blue')) targets.push(t);
                if (this.player.job === "Ассасин" && (c % 2 === 0)) targets.push(t);
            }
        }

        this.tweens.add({
            targets: targets,
            tintFill: true,
            tint: 0xffffff,
            duration: 800,
            onComplete: () => {
                let anims = [];
                targets.forEach(t => {
                    this.applyEffect(t.type, 1.3);
                    this.grid[t.gridR][t.gridC] = null;
                    anims.push(new Promise(res => {
                        this.tweens.add({
                            targets: t, scale: 0, alpha: 0, duration: 500,
                            onComplete: () => { t.destroy(); res(); }
                        });
                    }));
                });

                Promise.all(anims).then(async () => {
                    await this.fillEmpty();
                    this.isAnimating = false;
                    this.updateUI();
                    this.turn = "MOB";
                    this.time.delayedCall(600, () => this.mobAI());
                });
            }
        });
    }

    // ==========================================
    // 4. ИГРОВОЕ ПОЛЕ (МЕХАНИКА)
    // ==========================================
    initGrid() {
        this.grid = []; this.isAnimating = false;
        for (let r=0; r<8; r++) {
            this.grid[r] = [];
            for (let c=0; c<8; c++) this.spawnTile(r, c);
        }
    }

    spawnTile(r, c, fromTop = false) {
        const types = ['Red', 'Blue', 'Green', 'Purple', 'Yellow'];
        let type = Phaser.Utils.Array.GetRandom(types);
        let tx = OFFSET_X + c * TILE_S, ty = OFFSET_Y + r * TILE_S;
        let tile = this.add.image(tx, fromTop ? ty - 500 : ty, `tile_${type}`).setDisplaySize(64, 64).setInteractive();
        tile.gridR = r; tile.gridC = c; tile.type = type;
        tile.on('pointerdown', () => this.handleTileClick(tile));
        this.grid[r][c] = tile;
        if (fromTop) this.tweens.add({ targets: tile, y: ty, duration: 500, ease: 'Bounce.easeOut' });
    }

    async handleTileClick(tile) {
        if (this.isAnimating || this.turn !== "PLAYER") return;
        if (!this.selectedTile) { 
            this.selectedTile = tile; tile.setTint(0xffff00); 
        } else {
            let dR = Math.abs(this.selectedTile.gridR - tile.gridR), dC = Math.abs(this.selectedTile.gridC - tile.gridC);
            if (dR + dC === 1) {
                await this.swapTiles(this.selectedTile, tile);
                if (!await this.checkMatches()) await this.swapTiles(this.selectedTile, tile);
                else { this.turn = "MOB"; this.time.delayedCall(800, () => this.mobAI()); }
            }
            if(this.selectedTile) this.selectedTile.clearTint();
            this.selectedTile = null;
        }
    }

    async swapTiles(t1, t2) {
        this.isAnimating = true;
        let r1 = t1.gridR, c1 = t1.gridC, r2 = t2.gridR, c2 = t2.gridC;
        this.grid[r1][c1] = t2; this.grid[r2][c2] = t1;
        t1.gridR = r2; t1.gridC = c2; t2.gridR = r1; t2.gridC = c1;
        return new Promise(res => {
            this.tweens.add({ targets: t1, x: OFFSET_X+c2*TILE_S, y: OFFSET_Y+r2*TILE_S, duration: 250 });
            this.tweens.add({ targets: t2, x: OFFSET_X+c1*TILE_S, y: OFFSET_Y+r1*TILE_S, duration: 250, onComplete: () => { this.isAnimating = false; res(); } });
        });
    }

    async checkMatches() {
        let toRem = new Set();
        for(let r=0; r<8; r++) for(let c=0; c<6; c++) 
            if(this.grid[r][c] && this.grid[r][c+1] && this.grid[r][c+2] &&
               this.grid[r][c].type===this.grid[r][c+1].type && this.grid[r][c].type===this.grid[r][c+2].type) 
            { toRem.add(this.grid[r][c]); toRem.add(this.grid[r][c+1]); toRem.add(this.grid[r][c+2]); }
        for(let c=0; c<8; c++) for(let r=0; r<6; r++)
            if(this.grid[r][c] && this.grid[r+1][c] && this.grid[r+2][c] &&
               this.grid[r][c].type===this.grid[r+1][c].type && this.grid[r][c].type===this.grid[r+2][c].type)
            { toRem.add(this.grid[r][c]); toRem.add(this.grid[r+1][c]); toRem.add(this.grid[r+2][c]); }
        
        if (toRem.size > 0) {
            toRem.forEach(t => { 
                if (this.turn === "PLAYER") this.applyEffect(t.type); else this.applyMobEffect(t.type);
                this.grid[t.gridR][t.gridC] = null;
                this.tweens.add({ targets: t, alpha: 0, scale: 0, duration: 200, onComplete: () => t.destroy() });
            });
            await new Promise(res => this.time.delayedCall(250, res));
            await this.fillEmpty();
            await this.checkMatches();
            return true;
        }
        return false;
    }

    async fillEmpty() {
        for(let c=0; c<8; c++) {
            let empty = 0;
            for(let r=7; r>=0; r--) {
                if(!this.grid[r][c]) empty++;
                else if(empty > 0) {
                    let t = this.grid[r][c];
                    this.grid[r+empty][c] = t; this.grid[r][c] = null;
                    t.gridR = r+empty;
                    this.tweens.add({ targets: t, y: OFFSET_Y+t.gridR*TILE_S, duration: 400, ease: 'Bounce.easeOut' });
                }
            }
            for(let i=0; i<empty; i++) this.spawnTile(i, c, true);
        }
        await new Promise(res => this.time.delayedCall(450, res));
    }

    // ==========================================
    // 5. УМНЫЙ ИИ (MOB AI)
    // ==========================================
    async mobAI() {
        if (this.mob.hp <= 0 || this.lootActive) return;
        let bestMove = null;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                let dirs = [[0, 1], [1, 0]];
                for (let [dr, dc] of dirs) {
                    let nr = r + dr, nc = c + dc;
                    if (nr < 8 && nc < 8) {
                        let temp = this.grid.map(row => row.map(t => t.type));
                        [temp[r][c], temp[nr][nc]] = [temp[nr][nc], temp[r][c]];
                        if (this.getMatchesCount(temp) > 0) bestMove = { r1: r, c1: c, r2: nr, c2: nc };
                    }
                }
            }
        }
        if (bestMove) await this.swapTiles(this.grid[bestMove.r1][bestMove.c1], this.grid[bestMove.r2][bestMove.c2]);
        await this.checkMatches();
        this.turn = "PLAYER";
        this.updateUI();
    }

    getMatchesCount(g) {
        let res = 0;
        for(let r=0; r<8; r++) for(let c=0; c<6; c++) if(g[r][c]===g[r][c+1] && g[r][c]===g[r][c+2]) res++;
        for(let c=0; c<8; c++) for(let r=0; r<6; r++) if(g[r][c]===g[r+1][c] && g[r][c]===g[r+2][c]) res++;
        return res;
    }

    // ==========================================
    // 6. ИНТЕРФЕЙС (UI) И ПРИМЕНЕНИЕ ЭФФЕКТОВ
    // ==========================================
    applyEffect(type, mult = 1) {
        let totalA = this.player.baseAtk + Object.values(this.player.equip).reduce((a, b) => a + (b.atk || 0), 0);
        if (type==='Red' || type==='Purple') this.mob.hp -= (totalA/5) * mult;
        if (type==='Green') this.player.hp = Math.min(this.player.maxHp, this.player.hp + 15);
        if (type==='Blue') this.player.mana = Math.min(100, this.player.mana + 10);
        if (type==='Yellow') this.player.gold += 5;
        this.updateUI();
    }

    applyMobEffect(type) {
        let d = this.mob.atk * 0.7;
        if(this.player.arm > 0) { let a = Math.min(this.player.arm, d); this.player.arm -= a; d -= a; }
        this.player.hp -= d;
        this.updateUI();
    }

    showMenu() {
        this.children.removeAll();
        this.add.text(GW/2, 100, "ВЫБЕРИТЕ ГЕРОЯ", { fontSize: '42px', fill: '#ffd700', fontStyle: 'bold' }).setOrigin(0.5);
        ["Воин", "Маг", "Лучник", "Ассасин"].forEach((name, i) => {
            let x = 300 * i + 150;
            let card = this.add.rectangle(x, 450, 260, 550, 0x1a1a1a).setInteractive().setStrokeStyle(2, 0xb48c46);
            this.add.image(x, 400, `hero_${name}`).setDisplaySize(200, 200);
            this.add.text(x, 600, name, { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
            card.on('pointerdown', () => {
                this.initPlayerData(name);
                this.spawnMob();
                this.children.removeAll();
                this.initGrid();
                this.createUI();
                this.updateUI();
            });
        });
    }

    createUI() {
        this.add.rectangle(175, 450, 310, 860, 0x191614).setStrokeStyle(2, 0xb48c46);
        this.add.image(175, 120, `hero_${this.player.job}`).setDisplaySize(140, 140);
        this.hpText = this.add.text(40, 210, "", { fontSize: '18px', fill: '#ff4444', fontStyle: 'bold' });
        this.hpBar = this.add.graphics();
        this.manaBar = this.add.graphics();
        this.goldText = this.add.text(40, 335, "", { fontSize: '22px', fill: '#ffd700' });
        this.ultBtn = this.add.rectangle(175, 410, 240, 50, 0x330033).setInteractive().setStrokeStyle(2, 0xaa00aa);
        this.add.text(175, 410, "СУПЕРУДАР", { fontSize: '20px', fill: '#fff' }).setOrigin(0.5);
        this.ultBtn.on('pointerdown', () => this.useUlt());
        this.equipLines = this.add.text(40, 480, "", { fontSize: '15px', lineSpacing: 8 });
        this.mobIcon = this.add.image(1050, 150, 'mob_icon').setDisplaySize(140, 140).setFlipX(true);
        this.mobHpText = this.add.text(1050, 250, "", { fontSize: '22px', fill: '#ff0000' }).setOrigin(0.5);
        this.mobHpBar = this.add.graphics();
    }

    updateUI() {
        this.hpText.setText(`ЖИЗНЬ: ${Math.floor(this.player.hp)}\nБРОНЯ: ${this.player.arm}`);
        this.hpBar.clear().fillStyle(0xff0000).fillRect(40, 250, (this.player.hp/this.player.maxHp)*270, 15);
        this.manaBar.clear().fillStyle(0x4444ff).fillRect(40, 305, (this.player.mana/100)*270, 12);
        this.ultBtn.setAlpha(this.player.mana >= 100 ? 1 : 0.5);
        this.goldText.setText(`ЗОЛОТО: ${this.player.gold}`);
        let eqS = "ИНВЕНТАРЬ:\n";
        for(let k in this.player.equip) eqS += `${this.player.equip[k].n}: +${this.player.equip[k].atk || 0} Атк / +${this.player.equip[k].arm || 0} Бр\n`;
        this.equipLines.setText(eqS);
        this.mobHpText.setText(`${this.mob.name}\nHP: ${Math.floor(this.mob.hp)}`);
        this.mobHpBar.clear().fillStyle(0xff0000).fillRect(945, 280, (Math.max(0, this.mob.hp)/this.mob.maxHp)*210, 15);

        if (this.mob.hp <= 0 && !this.lootActive) {
            this.lootActive = true;
            let loot = this.generateLoot();
            this.showLootWindow(loot);
            this.mob.hp = 1; // Заглушка
        }
        if(this.player.hp <= 0) location.reload();
    }

    // ==========================================
    // 7. ЛОГИКА ДРОПА (ЛУТ И РЕДКОСТЬ)
    // ==========================================
    generateLoot() {
        const rarities = [
            { n: 'Обычный', c: '#ffffff', mult: 1, chance: 60 },
            { n: 'Редкий', c: '#00ff00', mult: 1.5, chance: 25 },
            { n: 'Эпический', c: '#800080', mult: 2.2, chance: 10 },
            { n: 'Легендарный', c: '#ff8c00', mult: 3.5, chance: 5 }
        ];
        let rand = Phaser.Math.Between(1, 100);
        let cumulative = 0, rarity = rarities[0];
        for (let r of rarities) {
            cumulative += r.chance;
            if (rand <= cumulative) { rarity = r; break; }
        }
        const items = [
            { name: 'Шлем', slot: 'head', stat: 'arm' },
            { name: 'Доспех', slot: 'body', stat: 'arm' },
            { name: 'Меч', slot: 'weapon', stat: 'atk' },
            { name: 'Кольцо', slot: 'ring', stat: 'atk' }
        ];
        let type = Phaser.Utils.Array.GetRandom(items);
        let baseValue = this.player.level * 3;
        let finalValue = Math.floor(baseValue * rarity.mult);
        return { ...type, value: finalValue, rarityName: rarity.n, color: rarity.c };
    }

    showLootWindow(loot) {
        this.isAnimating = true;
        let container = this.add.container(GW/2, GH/2);
        let bg = this.add.rectangle(0, 0, 400, 300, 0x000000, 0.9).setStrokeStyle(3, 0xb48c46);
        let title = this.add.text(0, -110, "ТРОФЕЙ НАЙДЕН!", { fontSize: '28px', fill: '#ffd700' }).setOrigin(0.5);
        let itemDesc = this.add.text(0, -20, `${loot.rarityName} ${loot.name}\n+${loot.value} к ${loot.stat === 'atk' ? 'Атаке' : 'Броне'}`, { fontSize: '22px', fill: loot.color, align: 'center' }).setOrigin(0.5);

        let btnTake = this.add.rectangle(-100, 80, 150, 50, 0x224422).setInteractive().setStrokeStyle(2, 0xffffff);
        let txtTake = this.add.text(-100, 80, "ВЗЯТЬ", { fontSize: '20px' }).setOrigin(0.5);
        let btnSell = this.add.rectangle(100, 80, 150, 50, 0x442222).setInteractive().setStrokeStyle(2, 0xffffff);
        let txtSell = this.add.text(100, 80, "ПРОДАТЬ", { fontSize: '20px' }).setOrigin(0.5);

        container.add([bg, title, itemDesc, btnTake, txtTake, btnSell, txtSell]);

        btnTake.on('pointerdown', () => {
            this.player.equip[loot.slot] = { n: loot.name, [loot.stat]: loot.value, color: loot.color };
            this.player.arm = Object.values(this.player.equip).reduce((a, b) => a + (b.arm || 0), 0);
            container.destroy();
            this.startNextLevel();
        });

        btnSell.on('pointerdown', () => {
            this.player.gold += (this.player.level * 10);
            container.destroy();
            this.startNextLevel();
        });
    }

    startNextLevel() {
        this.player.level++;
        this.spawnMob();
        this.updateUI();
        this.isAnimating = false;
    }
}
