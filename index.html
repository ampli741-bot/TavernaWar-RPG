<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Magic Match 3 - Skeleton</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<div id="game-container" class="relative w-full h-full flex items-center justify-center">
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Overlay -->
    <div class="absolute top-4 left-4 right-4 flex justify-between items-start pointer-events-none">
        <div class="bg-black/60 p-3 rounded-lg border border-yellow-600/50 text-white">
            <div class="text-xs uppercase text-yellow-500 font-bold">–ó–æ–ª–æ—Ç–æ</div>
            <div id="gold-count" class="text-2xl font-mono">0</div>
        </div>
        <div class="bg-black/60 p-3 rounded-lg border border-blue-600/50 text-white">
            <div class="text-xs uppercase text-blue-400 font-bold">–°—á–µ—Ç</div>
            <div id="score-count" class="text-2xl font-mono">0</div>
        </div>
    </div>
</div>

<script>
/**
 * –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ù–ê–°–¢–†–û–ô–ö–ò
 */
const GRID_SIZE = 8;
const TILE_TYPES = ['fire', 'water', 'leaf', 'gold', 'skull'];
const COLORS = {
    fire: '#ff4d4d',
    water: '#4d94ff',
    leaf: '#4dff88',
    gold: '#ffd700',
    skull: '#b366ff'
};

const SYMBOLS = {
    fire: 'üî•',
    water: 'üíß',
    leaf: 'üåø',
    gold: 'üí∞',
    skull: 'üíÄ'
};

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
let config = {
    tileWidth: 0,
    tileHeight: 0,
    offsetX: 0,
    offsetY: 0,
    canvasWidth: 0,
    canvasHeight: 0
};

/**
 * –°–û–°–¢–û–Ø–ù–ò–ï –ò–ì–†–´
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let grid = [];
let score = 0;
let gold = 0;
let isAnimating = false;
let selectedTile = null;
let particles = [];
let floatingTexts = [];

/**
 * –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
 */
function init() {
    createGrid(); // –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–µ–º —Å–µ—Ç–∫—É
    resize();     // –ó–∞—Ç–µ–º –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã
    window.addEventListener('resize', resize);
    canvas.addEventListener('pointerdown', handlePointerDown);
    
    // –ù–∞—á–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏
    requestAnimationFrame(gameLoop);
}

function resize() {
    const container = document.getElementById('game-container');
    if (!container) return;
    
    const size = Math.min(container.clientWidth, container.clientHeight) * 0.95;
    
    canvas.width = size;
    canvas.height = size;
    
    config.canvasWidth = size;
    config.canvasHeight = size;
    config.tileWidth = size / GRID_SIZE;
    config.tileHeight = size / GRID_SIZE;
    
    // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –≤—Å–µ—Ö –ø–ª–∏—Ç–æ–∫ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞
    if (grid.length > 0) {
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (grid[r][c]) {
                    grid[r][c].x = c * config.tileWidth;
                    grid[r][c].y = r * config.tileHeight;
                }
            }
        }
    }
    
    draw();
}

function createGrid() {
    grid = [];
    for (let r = 0; r < GRID_SIZE; r++) {
        grid[r] = [];
        for (let c = 0; c < GRID_SIZE; c++) {
            grid[r][c] = {
                type: getRandomType(),
                x: c * config.tileWidth,
                y: r * config.tileHeight,
                alpha: 1,
                scale: 1,
                isRemoving: false
            };
        }
    }
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞—á–∞–ª—å–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è (–±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏)
    resolveMatches(true);
}

function getRandomType() {
    return TILE_TYPES[Math.floor(Math.random() * TILE_TYPES.length)];
}

/**
 * –õ–û–ì–ò–ö–ê –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–Ø
 */
function handlePointerDown(e) {
    if (isAnimating) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const col = Math.floor(x / config.tileWidth);
    const row = Math.floor(y / config.tileHeight);
    
    if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
        if (!selectedTile) {
            selectedTile = { row, col };
        } else {
            const dr = Math.abs(selectedTile.row - row);
            const dc = Math.abs(selectedTile.col - col);
            
            if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                swapTiles(selectedTile.row, selectedTile.col, row, col);
            }
            selectedTile = null;
        }
    }
    draw();
}

async function swapTiles(r1, c1, r2, c2) {
    isAnimating = true;
    
    // –í–∏–∑—É–∞–ª—å–Ω—ã–π –æ–±–º–µ–Ω —Ç–∏–ø–∞–º–∏
    const tempType = grid[r1][c1].type;
    grid[r1][c1].type = grid[r2][c2].type;
    grid[r2][c2].type = tempType;
    
    const matches = checkMatches();
    
    if (!matches) {
        // –ï—Å–ª–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞–∑–∞–¥ —á–µ—Ä–µ–∑ –Ω–µ–±–æ–ª—å—à—É—é –ø–∞—É–∑—É
        setTimeout(() => {
            grid[r2][c2].type = grid[r1][c1].type;
            grid[r1][c1].type = tempType;
            isAnimating = false;
            draw();
        }, 300);
    } else {
        await resolveMatches();
        isAnimating = false;
    }
}

/**
 * –ü–û–ò–°–ö –ò –£–î–ê–õ–ï–ù–ò–ï –°–û–í–ü–ê–î–ï–ù–ò–ô
 */
function checkMatches() {
    let toRemove = new Set();
    
    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE - 2; c++) {
            let type = grid[r][c].type;
            if (type && grid[r][c+1] && grid[r][c+2] && 
                type === grid[r][c+1].type && type === grid[r][c+2].type) {
                toRemove.add(`${r},${c}`);
                toRemove.add(`${r},${c+1}`);
                toRemove.add(`${r},${c+2}`);
            }
        }
    }
    
    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
    for (let c = 0; c < GRID_SIZE; c++) {
        for (let r = 0; r < GRID_SIZE - 2; r++) {
            let type = grid[r][c].type;
            if (type && grid[r+1] && grid[r+2] && 
                type === grid[r+1][c].type && type === grid[r+2][c].type) {
                toRemove.add(`${r},${c}`);
                toRemove.add(`${r+1},${c}`);
                toRemove.add(`${r+2},${c}`);
            }
        }
    }
    
    return toRemove.size > 0 ? Array.from(toRemove) : null;
}

async function resolveMatches(silent = false) {
    let matches = checkMatches();
    if (!matches) return;

    while (matches) {
        if (!silent) {
            // –ê–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
            await animateRemoval(matches);
            
            // –ù–∞—á–∏—Å–ª–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
            matches.forEach(m => {
                const [r, c] = m.split(',').map(Number);
                const type = grid[r][c].type;
                if (type === 'gold') gold += 10;
                score += 50;
                
                // –≠—Ñ—Ñ–µ–∫—Ç MP (–ú–∞–≥–∏—á–µ—Å–∫–∏–µ —á–∞—Å—Ç–∏—Ü—ã)
                createParticles(c * config.tileWidth + config.tileWidth/2, r * config.tileHeight + config.tileHeight/2, COLORS[type]);
            });
            updateUI();
        }

        // –£–¥–∞–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        matches.forEach(m => {
            const [r, c] = m.split(',').map(Number);
            grid[r][c].type = null;
        });

        // –°–º–µ—â–µ–Ω–∏–µ –≤–Ω–∏–∑
        dropTiles();
        
        // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö
        fillNewTiles();
        
        // –ü–∞—É–∑–∞ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
        await new Promise(res => setTimeout(res, 300));
        
        matches = checkMatches();
    }
}

function animateRemoval(matches) {
    return new Promise(resolve => {
        let frames = 0;
        const maxFrames = 15;
        
        matches.forEach(m => {
            const [r, c] = m.split(',').map(Number);
            grid[r][c].isRemoving = true;
        });

        function step() {
            frames++;
            matches.forEach(m => {
                const [r, c] = m.split(',').map(Number);
                if (grid[r][c]) {
                    grid[r][c].alpha = 1 - (frames / maxFrames);
                    grid[r][c].scale = 1 + (frames / maxFrames) * 0.5;
                }
            });
            
            draw();
            if (frames < maxFrames) {
                requestAnimationFrame(step);
            } else {
                matches.forEach(m => {
                    const [r, c] = m.split(',').map(Number);
                    if (grid[r][c]) {
                        grid[r][c].isRemoving = false;
                        grid[r][c].alpha = 1;
                        grid[r][c].scale = 1;
                    }
                });
                resolve();
            }
        }
        step();
    });
}

function dropTiles() {
    for (let c = 0; c < GRID_SIZE; c++) {
        let emptySpaces = 0;
        for (let r = GRID_SIZE - 1; r >= 0; r--) {
            if (grid[r][c].type === null) {
                emptySpaces++;
            } else if (emptySpaces > 0) {
                grid[r + emptySpaces][c].type = grid[r][c].type;
                grid[r][c].type = null;
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –ø–∞–¥–µ–Ω–∏—è (–Ω–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è Lerp)
                grid[r + emptySpaces][c].y = r * config.tileHeight;
            }
        }
    }
}

function fillNewTiles() {
    for (let c = 0; c < GRID_SIZE; c++) {
        for (let r = 0; r < GRID_SIZE; r++) {
            if (grid[r][c].type === null) {
                grid[r][c].type = getRandomType();
                // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —ç–∫—Ä–∞–Ω–∞ —Å–≤–µ—Ä—Ö—É
                grid[r][c].y = -config.tileHeight * 2;
            }
        }
    }
}

/**
 * –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø
 */
function draw() {
    // –ï—Å–ª–∏ —Å–µ—Ç–∫–∞ –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–Ω–∞, –≤—ã—Ö–æ–¥–∏–º
    if (!grid || grid.length === 0) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // –§–æ–Ω
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // –°–µ—Ç–∫–∞
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 1;
    for(let i=0; i<=GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * config.tileWidth, 0);
        ctx.lineTo(i * config.tileWidth, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i * config.tileHeight);
        ctx.lineTo(canvas.width, i * config.tileHeight);
        ctx.stroke();
    }

    // –ü–ª–∏—Ç–∫–∏
    for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
            const tile = grid[r][c];
            if (tile && tile.type) {
                // –ü–ª–∞–≤–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
                const targetY = r * config.tileHeight;
                if (Math.abs(tile.y - targetY) > 0.1) {
                    tile.y += (targetY - tile.y) * 0.2;
                } else {
                    tile.y = targetY;
                }
                
                drawTile(tile.x, tile.y, tile.type, tile.alpha, tile.scale, (selectedTile && selectedTile.row === r && selectedTile.col === c));
            }
        }
    }
    
    drawParticles();
}

function drawTile(x, y, type, alpha, scale, isSelected) {
    const w = config.tileWidth;
    const h = config.tileHeight;
    const padding = 4;
    
    ctx.save();
    ctx.translate(x + w/2, y + h/2);
    ctx.scale(scale, scale);
    ctx.globalAlpha = alpha;
    
    // –°—Ç–∏–ª–∏–∑–∞—Ü–∏—è –ø–ª–∏—Ç–∫–∏
    ctx.fillStyle = '#2a2a2a';
    ctx.shadowBlur = isSelected ? 20 : 5;
    ctx.shadowColor = isSelected ? COLORS[type] : 'rgba(0,0,0,0.5)';
    
    const rounded = 10;
    ctx.beginPath();
    ctx.roundRect(-w/2 + padding, -h/2 + padding, w - padding*2, h - padding*2, rounded);
    ctx.fill();
    
    // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç
    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, w/2);
    grad.addColorStop(0, COLORS[type] + '33');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fill();
    
    // –û–±–≤–æ–¥–∫–∞
    ctx.strokeStyle = isSelected ? '#fff' : COLORS[type] + '66';
    ctx.lineWidth = isSelected ? 3 : 1;
    ctx.stroke();
    
    // –°–∏–º–≤–æ–ª
    ctx.shadowBlur = 10;
    ctx.shadowColor = COLORS[type];
    ctx.fillStyle = 'white';
    ctx.font = `${Math.floor(w * 0.45)}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(SYMBOLS[type], 0, 0);

    // –≠—Ñ—Ñ–µ–∫—Ç MP –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏
    if (alpha < 1) {
        ctx.font = `bold ${Math.floor(w * 0.25)}px sans-serif`;
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.fillText("MP", 0, h/4);
    }
    
    ctx.restore();
}

/**
 * –ß–ê–°–¢–ò–¶–´
 */
function createParticles(x, y, color) {
    for (let i = 0; i < 12; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            life: 1.0,
            color
        });
    }
}

function drawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.025;
        
        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

function updateUI() {
    document.getElementById('gold-count').innerText = gold;
    document.getElementById('score-count').innerText = score;
}

function gameLoop() {
    draw();
    requestAnimationFrame(gameLoop);
}

window.onload = init;
</script>
</body>
</html>
