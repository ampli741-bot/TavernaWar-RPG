<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ú–∞–≥–∏—á–µ—Å–∫–∏–π –ú–∞—Ç—á-3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: #1a1a1a;
            color: #fff;
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #game-canvas {
            display: block;
            margin: 0 auto;
            touch-action: none;
        }
        .ui-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 15px;
            border: 2px solid #444;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div class="ui-panel">
    <div>–ó–æ–ª–æ—Ç–æ: <span id="gold-value">0</span></div>
    <div>–ú–∞–Ω–∞ (MP): <span id="mp-value">0</span></div>
</div>
<canvas id="game-canvas"></canvas>

<script>
    // --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏ –°–æ—Å—Ç–æ—è–Ω–∏–µ ---
    const GRID_SIZE = 8;
    const TILE_TYPES = ['fire', 'leaf', 'coin', 'mana', 'demon'];
    const COLORS = {
        fire: '#ff4d00',
        leaf: '#44ff00',
        coin: '#ffd700',
        mana: '#00ccff',
        demon: '#cc00ff'
    };

    // –≠–º–æ–¥–∑–∏ –∫–∞–∫ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∞—Å—Å–µ—Ç—ã (—Å–∫–µ–ª–µ—Ç)
    const ICONS = {
        fire: 'üî•',
        leaf: 'üçÉ',
        coin: 'üí∞',
        mana: 'üåÄ',
        demon: 'üòà'
    };

    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    let tileSize = 0;
    let grid = [];
    let selectedTile = null;
    let isAnimating = false;
    let score = { gold: 0, mp: 0 };
    
    // –≠—Ñ—Ñ–µ–∫—Ç—ã
    let particles = [];

    // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---
    function init() {
        resize();
        createGrid();
        requestAnimationFrame(gameLoop);
    }

    function resize() {
        const minDim = Math.min(window.innerWidth, window.innerHeight);
        canvas.width = minDim * 0.9;
        canvas.height = canvas.width;
        tileSize = canvas.width / GRID_SIZE;
    }

    function createGrid() {
        for (let r = 0; r < GRID_SIZE; r++) {
            grid[r] = [];
            for (let c = 0; c < GRID_SIZE; c++) {
                grid[r][c] = {
                    r, c,
                    type: getRandomType(),
                    x: c * tileSize,
                    y: r * tileSize,
                    targetY: r * tileSize,
                    alpha: 1,
                    scale: 1,
                    isDestroying: false
                };
            }
        }
        // –£–±–∏—Ä–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è (—É–ø—Ä–æ—â–µ–Ω–æ –¥–ª—è —Å–∫–µ–ª–µ—Ç–∞)
    }

    function getRandomType() {
        return TILE_TYPES[Math.floor(Math.random() * TILE_TYPES.length)];
    }

    // --- –õ–æ–≥–∏–∫–∞ —á–∞—Å—Ç–∏—Ü (–†–∞—Å—Å—ã–ø–∞–Ω–∏–µ) ---
    function createExplosion(x, y, color) {
        const count = 8;
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x + tileSize / 2,
                y: y + tileSize / 2,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                size: Math.random() * 5 + 2,
                color: color,
                life: 1.0
            });
        }
    }

    // --- –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª ---
    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        update();
        draw();
        
        requestAnimationFrame(gameLoop);
    }

    function update() {
        let moving = false;
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∏—Ç–æ–∫
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const t = grid[r][c];
                if (!t) continue;

                // –ê–Ω–∏–º–∞—Ü–∏—è –ø–∞–¥–µ–Ω–∏—è
                if (t.y < t.targetY) {
                    t.y += 10;
                    if (t.y > t.targetY) t.y = t.targetY;
                    moving = true;
                }

                // –ê–Ω–∏–º–∞—Ü–∏—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è (–ø–ª–∞–≤–Ω–æ–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ)
                if (t.isDestroying) {
                    t.alpha -= 0.1;
                    t.scale -= 0.05; // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ —É–≤–µ–ª–∏—á–µ–Ω–∏—è
                    if (t.alpha <= 0) {
                        grid[r][c] = null;
                    }
                }
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            if (p.life <= 0) particles.splice(i, 1);
        }

        if (!moving && !isAnimating) {
            checkMatches();
        }
        
        isAnimating = moving;
    }

    function draw() {
        // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É (—Ñ–æ–Ω)
        ctx.strokeStyle = '#333';
        for(let i=0; i<=GRID_SIZE; i++) {
            ctx.beginPath(); ctx.moveTo(i*tileSize, 0); ctx.lineTo(i*tileSize, canvas.height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i*tileSize); ctx.lineTo(canvas.width, i*tileSize); ctx.stroke();
        }

        // –†–∏—Å—É–µ–º –ø–ª–∏—Ç–∫–∏
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const t = grid[r][c];
                if (!t) continue;

                ctx.save();
                ctx.translate(t.x + tileSize / 2, t.y + tileSize / 2);
                ctx.scale(t.scale, t.scale);
                ctx.globalAlpha = t.alpha;

                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–∞–º–∫–∏ –ø–ª–∏—Ç–∫–∏ (–∫–∞–∫ –Ω–∞ —Å–∫—Ä–∏–Ω–∞—Ö)
                ctx.fillStyle = '#222';
                ctx.beginPath();
                ctx.roundRect(-tileSize/2 + 5, -tileSize/2 + 5, tileSize - 10, tileSize - 10, 8);
                ctx.fill();
                ctx.strokeStyle = COLORS[t.type];
                ctx.lineWidth = 2;
                ctx.stroke();

                // –ò–∫–æ–Ω–∫–∞
                ctx.fillStyle = COLORS[t.type];
                ctx.font = `${tileSize * 0.5}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ICONS[t.type], 0, 0);

                if (t.type === 'mana') {
                    ctx.font = `${tileSize * 0.2}px Arial`;
                    ctx.fillText('MP', 0, tileSize * 0.35);
                }

                ctx.restore();
            }
        }

        // –†–∏—Å—É–µ–º —á–∞—Å—Ç–∏—Ü—ã (—Ä–∞—Å—Å—ã–ø–∞–Ω–∏–µ)
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });

        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞
        if (selectedTile) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.strokeRect(selectedTile.c * tileSize, selectedTile.r * tileSize, tileSize, tileSize);
        }
    }

    // --- –ú–µ—Ö–∞–Ω–∏–∫–∞ –ú–∞—Ç—á–µ–π ---
    function checkMatches() {
        let toDestroy = [];

        // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ
        for (let r = 0; r < GRID_SIZE; r++) {
            let count = 1;
            for (let c = 1; c <= GRID_SIZE; c++) {
                if (c < GRID_SIZE && grid[r][c] && grid[r][c-1] && grid[r][c].type === grid[r][c-1].type) {
                    count++;
                } else {
                    if (count >= 3) {
                        for (let i = 1; i <= count; i++) toDestroy.push({r, c: c - i});
                    }
                    count = 1;
                }
            }
        }

        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ
        for (let c = 0; c < GRID_SIZE; c++) {
            let count = 1;
            for (let r = 1; r <= GRID_SIZE; r++) {
                if (r < GRID_SIZE && grid[r][c] && grid[r-1][c] && grid[r][c].type === grid[r-1][c].type) {
                    count++;
                } else {
                    if (count >= 3) {
                        for (let i = 1; i <= count; i++) toDestroy.push({r: r - i, c});
                    }
                    count = 1;
                }
            }
        }

        if (toDestroy.length > 0) {
            toDestroy.forEach(pos => {
                const t = grid[pos.r][pos.c];
                if (t && !t.isDestroying) {
                    t.isDestroying = true;
                    // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç —Ä–∞—Å—Å—ã–ø–∞–Ω–∏—è
                    createExplosion(t.x, t.y, COLORS[t.type]);
                    
                    // –°–±–æ—Ä —Ä–µ—Å—É—Ä—Å–æ–≤
                    if (t.type === 'coin') score.gold += 10;
                    if (t.type === 'mana') score.mp += 5;
                    updateUI();
                }
            });
            setTimeout(fillGaps, 300);
        }
    }

    function fillGaps() {
        for (let c = 0; c < GRID_SIZE; c++) {
            let emptySpaces = 0;
            for (let r = GRID_SIZE - 1; r >= 0; r--) {
                if (grid[r][c] === null) {
                    emptySpaces++;
                } else if (emptySpaces > 0) {
                    const t = grid[r][c];
                    grid[r + emptySpaces][c] = t;
                    t.r = r + emptySpaces;
                    t.targetY = t.r * tileSize;
                    grid[r][c] = null;
                }
            }
            for (let i = 0; i < emptySpaces; i++) {
                const r = emptySpaces - 1 - i;
                grid[r][c] = {
                    r, c,
                    type: getRandomType(),
                    x: c * tileSize,
                    y: -tileSize * (i + 1),
                    targetY: r * tileSize,
                    alpha: 1,
                    scale: 1,
                    isDestroying: false
                };
            }
        }
    }

    function updateUI() {
        document.getElementById('gold-value').innerText = score.gold;
        document.getElementById('mp-value').innerText = score.mp;
    }

    // --- –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ ---
    canvas.addEventListener('pointerdown', e => {
        if (isAnimating) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const c = Math.floor(x / tileSize);
        const r = Math.floor(y / tileSize);

        if (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
            if (!selectedTile) {
                selectedTile = { r, c };
            } else {
                const dist = Math.abs(r - selectedTile.r) + Math.abs(c - selectedTile.c);
                if (dist === 1) {
                    swapTiles(selectedTile.r, selectedTile.c, r, c);
                }
                selectedTile = null;
            }
        }
    });

    function swapTiles(r1, c1, r2, c2) {
        const t1 = grid[r1][c1];
        const t2 = grid[r2][c2];

        // –í–∏–∑—É–∞–ª—å–Ω—ã–π —Å–≤–æ–ø
        const tempX = t1.x; const tempY = t1.y;
        t1.x = t2.x; t1.y = t2.y;
        t1.targetY = t2.y;
        t2.x = tempX; t2.y = tempY;
        t2.targetY = tempY;

        grid[r1][c1] = t2;
        grid[r2][c2] = t1;
        t1.r = r2; t1.c = c2;
        t2.r = r1; t2.c = c1;
    }

    window.onload = init;
</script>
</body>
</html>
